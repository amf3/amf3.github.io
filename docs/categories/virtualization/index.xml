<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Virtualization on Adam Faris</title>
    <link>https://amf3.github.io/categories/virtualization/</link>
    <description>Recent content in Virtualization on Adam Faris</description>
    <generator>Hugo -- 0.152.2</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Feb 2026 16:29:59 -0800</lastBuildDate>
    <atom:link href="https://amf3.github.io/categories/virtualization/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Open Container Image Format</title>
      <link>https://amf3.github.io/articles/virtualization/oci_image/</link>
      <pubDate>Mon, 23 Feb 2026 16:29:59 -0800</pubDate>
      <guid>https://amf3.github.io/articles/virtualization/oci_image/</guid>
      <description>From Local TAR file to Open Container Image</description>
      <content:encoded><![CDATA[<p><img alt="Image of shipping containers on the pier" loading="lazy" src="/articles/virtualization/oci_image/assets/containers.jpg"></p>
<p>Forget about needing Docker&rsquo;s buildx or Redhat&rsquo;s buildah for this OCI container image deep dive. I will explain the OCI container image
model and demonstrate building a new container image with a little JSON and a few SHA256 hash sums.  You will understand that container images
aren&rsquo;t a file you download, but instead a graph of nodes and how the nodes are addressed after reading this article.</p>
<h2 id="the-build-artifact">The Build Artifact</h2>
<p>A build artifact is the reproducible output created after building an application. The artifact is complete and contains all neccessary
directories, compiled binaries, configs, libraries, and a directory structure.  Often this is packged as a tar archive (tar) or zip file,
but isn&rsquo;t a requriement.  The artifact contains everything needed for the application to execute in its intended environment, (arm, x86, linux,
windows).  There are no container specific files within the artifact, it&rsquo;s just a directory tree of files.</p>
<p>Convention refers to the directory tree as a <strong>root filesystem</strong> when working with container images.  This is due to the
directory tree being mounted at / inside the container.  The root fs is not a block device filesystem like ext4.</p>
<h2 id="oci-container-image-description">OCI Container Image Description</h2>
<p>A container image consists of a root filesystem and a set of JSON documents describing how the filesystem should be used.
Each component of the image is stored as a content addressible blob, identified by the SHA256 hash of the blobs contents.  Because identity is
derived from content, any modification produces a new digest and a new image identitify instead of mutating the existing image.</p>
<p>The image contains a manifest file which ties the blobs together.  The manifest references the filesystem layers and configuration file by
their SHA256 digests.  The configuration file defines how to run the filesystem as a container by listing what process to start, the target
operating system, CPU architecture, environment variables, working directory and other execution settings.</p>
<p>Additional metadata can be associated with an image after its created, like a Software Bill of Materials. This is done by publishing a
seperate artifact that references the images manifest digest.  Associating metadata by reference keeps the original image unchanged.</p>
<p>Because a container image is composed of multiple content addressible blobs connected by digest references, it does not exist as a single
downloadable file.  Instead a container image forms a directed graph of nodes, a manifest pointing to configuration and layer blobs, and
potentially additional artifacts pointing back to the manifest. Container tooling understands how to traverse this graph and retrieve the
referenced content.</p>
<h2 id="elements-of-a-oci-container-image">Elements of a OCI Container Image</h2>
<p>When stored on disk, the graph of object addressable objects is represented using a
<a href="https://github.com/opencontainers/image-spec/blob/main/image-layout.md">standard layout</a>. The layout stores objects by hash and the
JSON descriptors define the edges between those objects. Each object is stored under <code>blobs/&lt;algorithm&gt;/&lt;digest&gt;</code>, where the filename is the
cryptographic hash of its contents. If the contents change, the filename must change.</p>
<pre tabindex="0"><code>.
├── blobs
│   └── sha256
│       ├── 17eec7bbc9d79fa397ac95c7283ecd04d1fe6978516932a3db110c6206430809
│       ├── 1b44b5a3e06a9aae883e7bf25e45c100be0bb81a0e01b32de604f3ac44711634
│       └── 2771e37a12b7bcb2902456ecf3f29bf9ee11ec348e66e8eb322d9780ad7fc2df
├── index.json
└── oci-layout
</code></pre><p>The <code>oci-layout</code> file declares that the top level directory follows the OCI Image Layout specification and indicates the layout version.</p>
<pre tabindex="0"><code>{
    &#34;imageLayoutVersion&#34;: &#34;1.0.0&#34;
}
</code></pre><p>The <code>index.json</code> file is the entry point of the container image and the root of the graph. The <strong>tag</strong> &ldquo;latest&rdquo;
(&ldquo;org.opencontainers.image.ref.name&rdquo;: &ldquo;latest&rdquo;) is mapped to a specific digest
(digest&quot;: &ldquo;sha256:2771e37a12b7bcb2902456ecf3f29bf9ee11ec348e66e8eb322d9780ad7fc2df&rdquo;) that is marked as the <strong>manifest</strong>
(&ldquo;mediaType&rdquo;: &ldquo;application/vnd.oci.image.manifest.v1+json&rdquo;).</p>
<pre tabindex="0"><code>{
  &#34;schemaVersion&#34;: 2,
  &#34;manifests&#34;: [
    {
      &#34;mediaType&#34;: &#34;application/vnd.oci.image.manifest.v1+json&#34;,
      &#34;digest&#34;: &#34;sha256:2771e37a12b7bcb2902456ecf3f29bf9ee11ec348e66e8eb322d9780ad7fc2df&#34;,
      &#34;size&#34;: 1035,
      &#34;annotations&#34;: {
        &#34;org.opencontainers.image.ref.name&#34;: &#34;latest&#34;
      }
    }
  ]
}
</code></pre><p>The <code>manifest</code> at blobs/sha256/2771e&hellip;c2df declares the
image configuration and the
ordered set of filesystem layers. This example contains a single filesystem layer.  In general, the
<strong>layers</strong> array can contain multiple entries, which are applied in order to construct the root
filesystem.</p>
<pre tabindex="0"><code>{
  &#34;schemaVersion&#34;: 2,
  &#34;mediaType&#34;: &#34;application/vnd.oci.image.manifest.v1+json&#34;,
  &#34;config&#34;: {
    &#34;mediaType&#34;: &#34;application/vnd.oci.image.config.v1+json&#34;,
    &#34;digest&#34;: &#34;sha256:1b44b5a3e06a9aae883e7bf25e45c100be0bb81a0e01b32de604f3ac44711634&#34;,
    &#34;size&#34;: 547
  },
  &#34;layers&#34;: [
    {
      &#34;mediaType&#34;: &#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;,
      &#34;digest&#34;: &#34;sha256:17eec7bbc9d79fa397ac95c7283ecd04d1fe6978516932a3db110c6206430809&#34;,
      &#34;size&#34;: 2380
    }
  ],
...
</code></pre><p>The trust chain is explicit with a container image. The entry point, index.json, selects a
<a href="https://github.com/opencontainers/image-spec/blob/main/media-types.md">manifest by digest</a>. The
manifest selects its config and ordered filesystem layers by digest. The filename of each object under
blobs/sha256 must match its contents hash.</p>
<p>When selecting an image by tag, we are unknowingly selecting by digest.  While tags are mutable references, digests are not. This is why the
tag &ldquo;latest&rdquo; can reference a different digest then the one currently in use.</p>
<h2 id="oci-container-image-demo">OCI Container Image Demo</h2>
<p>We will construct an OCI container image manually to demonstrate that an image consists only of content addressed blobs and a few
JSON documents.  This is not a production workflow. The goal is to expose the model, not replace existing tooling.  Because higher
level objects reference lower level objects by digest, construction begins with the leaves of the graph. Any modification
to an object would change the layer digest, which would in turn invalidate the config and manifest digests above it.</p>
<p>Begin with creating a staging directory for building our conatiner image and the compiled application.  The application is statically
compiled and named <strong>hello</strong>. It prints a greeting defined by the <a href="./assets/hello.go">GREETING</a> environment variable, else it prints &ldquo;Hello World&rdquo;.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ mkdir -p myapp/blobs/sha256
</span></span><span style="display:flex;"><span>$ tree myapp
</span></span><span style="display:flex;"><span>myapp
</span></span><span style="display:flex;"><span>└── blobs
</span></span><span style="display:flex;"><span>    └── sha256
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ ./build/hello 
</span></span><span style="display:flex;"><span>HELLO WORLD!!!
</span></span><span style="display:flex;"><span>$ GREETING<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;HELLO ADAM&#34;</span> ./build/hello 
</span></span><span style="display:flex;"><span>HELLO ADAM
</span></span></code></pre></div><p>Next turn the &ldquo;hello&rdquo; application into a root filesystem blob.  Currently the build artifact is in the &ldquo;./build&rdquo; directory which
gets archived with tar.  Compute the SHA256 digest on the tar archive and the archive is copied to the staging directory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ tree build/
</span></span><span style="display:flex;"><span>build/
</span></span><span style="display:flex;"><span>└── hello
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ tar --numeric-owner --owner<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> --group<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -cf layer.tar -C build .
</span></span><span style="display:flex;"><span>$ sha256sum layer.tar 
</span></span><span style="display:flex;"><span>0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb  layer.tar
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ cp layer.tar myapp/blobs/sha256/0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ tree myapp/
</span></span><span style="display:flex;"><span>myapp/
</span></span><span style="display:flex;"><span>└── blobs
</span></span><span style="display:flex;"><span>    └── sha256
</span></span><span style="display:flex;"><span>        └── 0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb
</span></span></code></pre></div><p>Create a config object which tells the container runtime how to execute the filesystem. For simplicity this example uses an uncompressed tar
archive. The diff_ids value matches the layer digest.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ cat config.json 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;architecture&#34;</span>: <span style="color:#e6db74">&#34;amd64&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;os&#34;</span>: <span style="color:#e6db74">&#34;linux&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;config&#34;</span>: <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Env&#34;</span>: <span style="color:#f92672">[]</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Entrypoint&#34;</span>: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/hello&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;rootfs&#34;</span>: <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;layers&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;diff_ids&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;sha256:0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ sha256sum config.json
</span></span><span style="display:flex;"><span>f86f75f0d7a7dd4c951a158aca51894ab59f46b0348558a341a589bfcc0d253c  config.json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ cp config.json myapp/blobs/sha256/f86f75f0d7a7dd4c951a158aca51894ab59f46b0348558a341a589bfcc0d253c
</span></span></code></pre></div><p>The manifest binds the configuration and layer digests into a single image descriptor. The manifest
file also gets hashed and stored in the staging directory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ cat manifest 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schemaVersion&#34;</span>: 2,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;mediaType&#34;</span>: <span style="color:#e6db74">&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;config&#34;</span>: <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;mediaType&#34;</span>: <span style="color:#e6db74">&#34;application/vnd.oci.image.config.v1+json&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;digest&#34;</span>: <span style="color:#e6db74">&#34;sha256:f86f75f0d7a7dd4c951a158aca51894ab59f46b0348558a341a589bfcc0d253c&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;size&#34;</span>: <span style="color:#ae81ff">255</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;layers&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;mediaType&#34;</span>: <span style="color:#e6db74">&#34;application/vnd.oci.image.layer.v1.tar&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;digest&#34;</span>: <span style="color:#e6db74">&#34;sha256:0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;size&#34;</span>: <span style="color:#ae81ff">1914880</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ sha256sum manifest
</span></span><span style="display:flex;"><span>d6fceb45932ad49b50f9a1e24b21691b60f861bf46ed9e4a47bd74b8401a2ecd  manifest
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ cp manifest myapp/blobs/sha256/d6fceb45932ad49b50f9a1e24b21691b60f861bf46ed9e4a47bd74b8401a2ecd
</span></span></code></pre></div><p>Finally create the container entry point and declare the myapp directory is the top level directory of a OCI compliant image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ cat myapp/index.json
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schemaVersion&#34;</span>: 2,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;manifests&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;mediaType&#34;</span>: <span style="color:#e6db74">&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;digest&#34;</span>: <span style="color:#e6db74">&#34;sha256:d6fceb45932ad49b50f9a1e24b21691b60f861bf46ed9e4a47bd74b8401a2ecd&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;size&#34;</span>: 476,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;annotations&#34;</span>: <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;org.opencontainers.image.ref.name&#34;</span>: <span style="color:#e6db74">&#34;latest&#34;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ cat myapp/oci-layout
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;imageLayoutVersion&#34;</span>: <span style="color:#e6db74">&#34;1.0.0&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>The image layout is now complete. We can import it into a runtime and execute it.</p>
<pre tabindex="0"><code>adam@charizard:~/foo/demo$ skopeo copy oci:./myapp docker-daemon:myapp:latest
Getting image source signatures
Copying blob 0f11da71a27a done   | 
Copying config f86f75f0d7 done   | 
Writing manifest to image destination

$ docker run --rm myapp:latest 
HELLO WORLD!!!
$ docker run --rm -e GREETING=&#34;Hello OCI image&#34; myapp:latest 
Hello OCI image
</code></pre><h2 id="why-the-model-matters">Why the Model Matters</h2>
<p>Understanding that a container image is a graph of content addressible blobs isn&rsquo;t trivia.  You gain several advantages when you stop seeing the image as a &ldquo;magic file&rdquo; and start seeing it
as a verifiable manifest.</p>
<p><strong>Tooling:</strong> Stop worrying about whether Docker is better than Podman. They are just different UI wrappers for the same OCI specification. Tooling becomes an implementation detail.</p>
<p><strong>Debugging:</strong> When an image is bloated or a layer is flagged by a security scanner, you don&rsquo;t need specialized tools to tell you why.  By inspecting the graph, you can identify exactly which
object introduced the content and then inspect that specific content.</p>
<p><strong>Supply Chain Confidence:</strong> By understanding that identity is derived from content you can verify image integrity or attach metadata (like SBOMs) with
confidence, knowing that objects bind to the manifest digest.</p>
<h2 id="closing">Closing</h2>
<p>My next article will use these principals in constructing a minimal distroless image without using a base image or package manager. Reach out on
<a href="https://bsky.app/profile/af9.us">BlueSky social</a> to let me know if these topics are useful or interesting.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Docker Socket Myths</title>
      <link>https://amf3.github.io/articles/virtualization/docker_socket/</link>
      <pubDate>Mon, 05 Jan 2026 12:25:30 -0800</pubDate>
      <guid>https://amf3.github.io/articles/virtualization/docker_socket/</guid>
      <description>Making Read Only Access Safer </description>
      <content:encoded><![CDATA[<p>There&rsquo;s a popular myth in the Docker community.
The myth is that it&rsquo;s possible to mount /var/run/docker.sock with read only options.  Even large container projects like
<a href="https://github.com/traefik/traefik/blob/f7280439e6378221a541910f43a01323d52db048/docs/content/user-guides/docker-compose/basic-example/index.md?plain=1#L122">Traefik</a>
get this wrong.</p>
<p>Bind mounting the Docker socket with read only options doesn&rsquo;t work the way one thinks it would.  This post will explain how using the
<strong>&quot;:ro&quot;</strong> option when mounting the Docker socket is little more than <a href="https://en.wikipedia.org/wiki/Security_theater">security theater</a> and to
discuss alternatives.</p>
<p>Please read this post if you&rsquo;re adding <code>/var/run/docker.sock:/var/run/docker.sock:ro</code> to Docker compose files.</p>
<h2 id="socket-behavior">Socket behavior</h2>
<h3 id="demo">Demo</h3>
<p>The issue isn&rsquo;t specific to Docker, instead its normal <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> behavior.  This is easily demonstrable
by creating a Unix socket with python and not using Docker at all.</p>
<p>This code block will create a Unix socket and wait for clients to connect.  When the client connects, the server prints received
data to standard out.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#75715e">#! /usr/bin/env python3</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Save as server.py</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> socket
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SOCK <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/tmp/control.sock&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>    os<span style="color:#f92672">.</span>unlink(SOCK)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">except</span> <span style="color:#a6e22e">FileNotFoundError</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>srv <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_UNIX, socket<span style="color:#f92672">.</span>SOCK_STREAM)
</span></span><span style="display:flex;"><span>srv<span style="color:#f92672">.</span>bind(SOCK)
</span></span><span style="display:flex;"><span>os<span style="color:#f92672">.</span>chmod(SOCK, <span style="color:#ae81ff">0o660</span>)   <span style="color:#75715e"># same write permissions that are used with docker.sock</span>
</span></span><span style="display:flex;"><span>srv<span style="color:#f92672">.</span>listen(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;listening&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>conn, _ <span style="color:#f92672">=</span> srv<span style="color:#f92672">.</span>accept()
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;client connected&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> conn<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> data:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;received:&#34;</span>, data<span style="color:#f92672">.</span>decode())
</span></span><span style="display:flex;"><span>    conn<span style="color:#f92672">.</span>sendall(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;ack</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div><p>The next block contains the client code.  Notice that the client socket path (/mnt/control.sock) is different from the server (/tmp/control.sock)
as it&rsquo;s using the read only bind mount created in the next step.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#75715e">#! /usr/bin/env python3</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Save as client.py</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> socket
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sock <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_UNIX, socket<span style="color:#f92672">.</span>SOCK_STREAM)
</span></span><span style="display:flex;"><span>sock<span style="color:#f92672">.</span>connect(<span style="color:#e6db74">&#34;/mnt/control.sock&#34;</span>)   <span style="color:#75715e"># connect to read-only mount point</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sock<span style="color:#f92672">.</span>sendall(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;This is a write string from the client</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>print(sock<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>))
</span></span></code></pre></div><p>Start the server code to create <code>/tmp/control.sock</code> and then bind mount the socket
to a new mount point with read-only access.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ sudo touch /mnt/control.sock                           <span style="color:#75715e"># create the mount point</span>
</span></span><span style="display:flex;"><span>$ sudo mount --bind /tmp/control.sock /mnt/control.sock  <span style="color:#75715e"># mount the socket to a new mount point</span>
</span></span><span style="display:flex;"><span>$ sudo mount -o remount,ro,bind /mnt/control.sock        <span style="color:#75715e"># Remount the socket mount point with read only options</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ mount | grep control.sock                              <span style="color:#75715e"># Display the read-only mount</span>
</span></span><span style="display:flex;"><span>tmpfs on /mnt/control.sock type tmpfs <span style="color:#f92672">(</span>ro,nosuid,nodev,size<span style="color:#f92672">=</span>16037780k,nr_inodes<span style="color:#f92672">=</span>1048576,inode64<span style="color:#f92672">)</span> 
</span></span></code></pre></div><p>Next run the client.  At this point it <strong>should not</strong> be possible to write to the socket, but this screen shot shows otherwise.</p>
<p><img alt="Screenshot Demo" loading="lazy" src="/articles/virtualization/docker_socket/assets/socket_demo.jpg"></p>
<p>If running the demo locally, don&rsquo;t forget to clean up the bind mount.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sudo umount /mnt/control.sock  <span style="color:#75715e"># unmount the read-only bind mount</span>
</span></span><span style="display:flex;"><span>sudo rm /mnt/control.sock      <span style="color:#75715e"># remove the mount point</span>
</span></span><span style="display:flex;"><span>rm /tmp/control.sock           <span style="color:#75715e"># remove the control.sock socket created by the python server code.</span>
</span></span></code></pre></div><h3 id="how-did-this-work">How did this work?</h3>
<p>A bind mount creates a second path to the same underlying kernel object. The &ldquo;ro&rdquo; mount option applies filesystem level
restrictions at the mount point, but does not change the behavior or permissions of the object being mounted.
When a process opens the object, further access control is determined by the object itself.</p>
<p>In this case, I&rsquo;m unable to delete the socket or change its metadata, but I can still connect to it.</p>
<p><img alt="Screenshot Failed Metadata Modification" loading="lazy" src="/articles/virtualization/docker_socket/assets/socket_mod.jpg"></p>
<p>The read and write behavior for a socket is different from a normal file. Files use the <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a>
and <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> system calls, sockets use
<a href="https://man7.org/linux/man-pages/man2/send.2.html">send()</a> and <a href="https://man7.org/linux/man-pages/man2/recv.2.html">recv()</a> system calls. The
read only mount option to the mount point representing the socket allows the client connection.  As send() is a different system call from
write(), send() is not blocked by the filesystem and data passes through the socket.</p>
<p>Socket behavior is the big misunderstanding in the Docker community. People conflate filesystem writes with sending
commands over a socket.</p>
<h2 id="docker-api">Docker API</h2>
<p>Docker defaulting to using Unix sockets isn&rsquo;t the problem. The issue is that the Docker API is course grained and was not built with
multitenancy in mind. While the <a href="https://docs.docker.com/reference/api/engine/version/v1.52/#tag/Container">Docker API</a> is built on HTTP
verbs, the HTTP endpoints don&rsquo;t map cleanly between safe and unsafe operations.  This makes verb based authorization ineffective
and explains why granting a container access to the Docker socket implicitly grants elevated capabilities for that container.</p>
<p>This example only uses HTTP GET requests to demonstrate the missing separation of safe and unsafe operations in the Docker API. The
example is able to exfiltrate TLS certificates from a running container. No container restart, privilege escalation, or filesystem write is required.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ <span style="color:#75715e"># Get a list of running containers</span>
</span></span><span style="display:flex;"><span>$ curl -s --unix-socket /var/run/docker.sock -X GET http://localhost/containers/json | jq <span style="color:#e6db74">&#39;.[] | {Names, Id, Image}&#39;</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Names&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;/cadvisor&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Id&#34;</span>: <span style="color:#e6db74">&#34;dfe1461c0a7a1a34bd0b4df6ccc1ecd77d1fc6483be80c248ef916a3e79d8bc9&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;Image&#34;</span>: <span style="color:#e6db74">&#34;gcr.io/cadvisor/cadvisor:v0.52.1&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># Exfiltrate certificates from the running cAdvisor container and save locally to a file named certificates.tar</span>
</span></span><span style="display:flex;"><span>$ curl -D - -s  --unix-socket /var/run/docker.sock -X GET http://localhost/containers/dfe1461c0a7a1a34bd0b4df6ccc1ecd77d1fc6483be80c248ef916a3e79d8bc9/archive?path<span style="color:#f92672">=</span>/etc/ssl -o certificates.tar 
</span></span><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Api-Version: 1.51
</span></span><span style="display:flex;"><span>Content-Type: application/x-tar
</span></span><span style="display:flex;"><span>Docker-Experimental: false
</span></span><span style="display:flex;"><span>Ostype: linux
</span></span><span style="display:flex;"><span>Server: Docker/28.5.2 <span style="color:#f92672">(</span>linux<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>X-Docker-Container-Path-Stat: eyJuYW1lIjoic3NsIiwic2l6ZSI6MTAsIm1vZGUiOjIxNDc0ODQxNDEsIm10aW1lIjoiMjAyNS0wMi0xM1QyMzoxNzowOFoiLCJsaW5rVGFyZ2V0IjoiIn0<span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>Date: Fri, <span style="color:#ae81ff">09</span> Jan <span style="color:#ae81ff">2026</span> 17:04:45 GMT
</span></span><span style="display:flex;"><span>Transfer-Encoding: chunked
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ <span style="color:#75715e"># List the contents of the uncompressed downloaded tar archive</span>
</span></span><span style="display:flex;"><span>$ tar -tf certificates.tar 
</span></span><span style="display:flex;"><span>ssl/
</span></span><span style="display:flex;"><span>ssl/cert.pem
</span></span><span style="display:flex;"><span>ssl/certs/
</span></span><span style="display:flex;"><span>ssl/certs/ca-certificates.crt
</span></span><span style="display:flex;"><span>ssl/ct_log_list.cnf
</span></span><span style="display:flex;"><span>ssl/ct_log_list.cnf.dist
</span></span></code></pre></div><p>Containers like cAdvisor or Traefik want access to the docker socket.  These are large projects and it&rsquo;s unlikely they would intentionally
publish harmful code.  But supply chain attacks are common and it&rsquo;s possible for malicious behavior to be introduced into a normally trusted
container.</p>
<p>When a container is granted access to the Docker socket, it implicitly inherits the full authority of the Docker API.  Docker does not have a
mechanism to distinguish between intended and unintended use of the API or a way to scope capabilites. This limitation is why socket proxies
exist, providing the missing authorization layer in Docker.</p>
<h2 id="socket-proxies">Socket Proxies</h2>
<p>A local proxy in front of the Docker socket can filter the endpoints a container can access.  Identity based solutions like
<a href="https://www.openpolicyagent.org">Open Policy Agent</a> are available and work well for human users with authentication tokens. But
containers don&rsquo;t use custom headers or use mTLS by default. The application code within the container would need to be modified
to send authentication with its requests.</p>
<p>This is why most socket proxy projects use topology for authentication and authorization.  The proxy is deployed
in a <a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/sidecar">side car</a> pattern with the application container, where
Docker socket access from the application container passes through the socket proxy container.  In topology based sidecar deployments,
<strong>where</strong> the request comes from determins what the request can do, not who is making the request.</p>
<p><img alt="Docker Socket Proxy Network" loading="lazy" src="/articles/virtualization/docker_socket/assets/docker_net.png"></p>
<p>Popular socket proxy projects are <a href="https://github.com/Tecnativa/docker-socket-proxy">Tecnativa socket-proxy</a> which uses HAProxy with configurable
endpoint filtering, and <a href="https://github.com/wollomatic/socket-proxy">Wollomatic socket-proxy</a> a Go based alternative. You configure these proxies
to allow specific endpoints. Like allowing Traefik access <code>containers/json</code> to discover services while blocking request to <code>containers/create</code>.</p>
<h3 id="tradeoffs">Tradeoffs</h3>
<p>There&rsquo;s no true identity-based authorization.  The proxy can&rsquo;t distinguish between legitmate requests from Traefik versus another container. The proxy
only knows requests coming from particular networks get particular permissions.</p>
<p>Duplicated infrastructure is another concern.  Each application needs its own proxy instance.  Running three containers that need Docker socket
access, results in configuring and deploying three separate proxies.</p>
<p>Policy/filter configuration within the proxy is static and set at deployment time.  It&rsquo;s not possible to dynamically adjust permissions based
on runtime conditions.</p>
<p>The Docker API design sneaks through proxy endpoints.  It&rsquo;s not possible to grant access to
<a href="https://docs.docker.com/reference/api/engine/version/v1.52/#tag/Image/operation/ImageInspect">container labels</a> without granting access to environment
variables, the latter likely contain application secrets.</p>
<p>Even with these limitations, socket proxies provide a significant security improvement over direct Docker socket mounts.  Socket proxies enforce
least privilege access at the API level, which is exactly where the authorization needs to happen.</p>
<h2 id="whats-next">What&rsquo;s Next?</h2>
<p>If you&rsquo;re currently mounting the Docker socket from your containers with <code>:ro</code> consider switching to a socket proxy solution.  The topology
based approach isn&rsquo;t perfect but it provides Docker API filtering that read only mounts can&rsquo;t.  Yes a socket proxy requires more setup, but it
provides a real security boundary rather than the appearance of one.</p>
<p>If you have thoughts on this content, let me know what you think on <a href="https://bsky.app/profile/af9.us">Bluesky</a>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Tips for working with qemu images</title>
      <link>https://amf3.github.io/articles/virtualization/qemuimage_tips/</link>
      <pubDate>Sun, 06 Apr 2025 07:41:29 -0400</pubDate>
      <guid>https://amf3.github.io/articles/virtualization/qemuimage_tips/</guid>
      <description>QEMU image file tips and tricks</description>
      <content:encoded><![CDATA[<p>QEMU uses files to emulate storage devices, and the features available
depend on how those files are created.  While QEMU can emulate disks from Parallels and VirtualBox, I’m going to
focus on the formats most commonly used in automation and scripting, <strong>raw</strong> and <strong>qcow2</strong>.</p>
<p>The default format is raw and raw offers the fewest features.  It&rsquo;s just plain storage.  The other format qcow2
supports compression, snapshots, and copy-on-write in addition to storage.</p>
<h2 id="raw-format">Raw Format</h2>
<p>Creating a raw disk with qemu-img is similar to using dd to create a block-based file. One can see this with
the output of <strong>qemu-img info</strong>.</p>
<p>Here I create two storage devices, one with qemu-img which defaults to the raw format and another with the
dd command.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img create my_disk.img +1m         
</span></span><span style="display:flex;"><span>Formatting <span style="color:#e6db74">&#39;my_disk.img&#39;</span>, fmt<span style="color:#f92672">=</span>raw size<span style="color:#f92672">=</span><span style="color:#ae81ff">1048576</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>/dev/zero of<span style="color:#f92672">=</span>my_block.file count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> bs<span style="color:#f92672">=</span>1m
</span></span><span style="display:flex;"><span>1+0 records in
</span></span><span style="display:flex;"><span>1+0 records out
</span></span></code></pre></div><p>Now let&rsquo;s use <strong>qemu-img info</strong> to confirm there&rsquo;s no difference between the two files.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img info my_disk.img  
</span></span><span style="display:flex;"><span>image: my_disk.img
</span></span><span style="display:flex;"><span>file format: raw
</span></span><span style="display:flex;"><span>virtual size: <span style="color:#ae81ff">1</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">1048576</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: <span style="color:#ae81ff">1</span> MiB
</span></span><span style="display:flex;"><span>Child node <span style="color:#e6db74">&#39;/file&#39;</span>:
</span></span><span style="display:flex;"><span>    filename: my_disk.img
</span></span><span style="display:flex;"><span>    protocol type: file
</span></span><span style="display:flex;"><span>    file length: <span style="color:#ae81ff">1</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">1048576</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    disk size: <span style="color:#ae81ff">1</span> MiB
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% qemu-img info my_block.file 
</span></span><span style="display:flex;"><span>image: my_block.file
</span></span><span style="display:flex;"><span>file format: raw
</span></span><span style="display:flex;"><span>virtual size: <span style="color:#ae81ff">1</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">1048576</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: <span style="color:#ae81ff">1</span> MiB
</span></span><span style="display:flex;"><span>Child node <span style="color:#e6db74">&#39;/file&#39;</span>:
</span></span><span style="display:flex;"><span>    filename: my_block.file
</span></span><span style="display:flex;"><span>    protocol type: file
</span></span><span style="display:flex;"><span>    file length: <span style="color:#ae81ff">1</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">1048576</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    disk size: <span style="color:#ae81ff">1</span> MiB
</span></span></code></pre></div><h2 id="qcow2-format">Qcow2 Format</h2>
<p>Creating a disk in <strong>qcow2</strong> format enables zlib compression by default.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img create -f qcow2 my_disk.img 1M 
</span></span><span style="display:flex;"><span>Formatting <span style="color:#e6db74">&#39;my_disk.img&#39;</span>, fmt<span style="color:#f92672">=</span>qcow2 cluster_size<span style="color:#f92672">=</span><span style="color:#ae81ff">65536</span> extended_l2<span style="color:#f92672">=</span>off compression_type<span style="color:#f92672">=</span>zlib size<span style="color:#f92672">=</span><span style="color:#ae81ff">1048576</span> lazy_refcounts<span style="color:#f92672">=</span>off refcount_bits<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% qemu-img info my_disk.img 
</span></span><span style="display:flex;"><span>image: my_disk.img
</span></span><span style="display:flex;"><span>file format: qcow2
</span></span><span style="display:flex;"><span>virtual size: <span style="color:#ae81ff">1</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">1048576</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: <span style="color:#ae81ff">196</span> KiB
</span></span><span style="display:flex;"><span>cluster_size: <span style="color:#ae81ff">65536</span>
</span></span><span style="display:flex;"><span>Format specific information:
</span></span><span style="display:flex;"><span>    compat: 1.1
</span></span><span style="display:flex;"><span>    compression type: zlib
</span></span><span style="display:flex;"><span>    lazy refcounts: false
</span></span><span style="display:flex;"><span>    refcount bits: <span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>    corrupt: false
</span></span><span style="display:flex;"><span>    extended l2: false
</span></span><span style="display:flex;"><span>Child node <span style="color:#e6db74">&#39;/file&#39;</span>:
</span></span><span style="display:flex;"><span>    filename: my_disk.img
</span></span><span style="display:flex;"><span>    protocol type: file
</span></span><span style="display:flex;"><span>    file length: <span style="color:#ae81ff">192</span> KiB <span style="color:#f92672">(</span><span style="color:#ae81ff">197120</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    disk size: <span style="color:#ae81ff">196</span> KiB
</span></span></code></pre></div><h1 id="tip-one---resize-an-image-file">Tip One - Resize an image file</h1>
<p>It&rsquo;s possible to grow or shrink a QEMU storage device.  Think of this as expanding the physical SSD itself, not the filesystem
that sits on it.  <strong>Important,</strong> when shrinking a image with negative values,
<strong>always shrink the filesystem first</strong> using resize2fs before running qemu-img resize <strong>or risk data corruption.</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img resize my_disk.img +1m  
</span></span><span style="display:flex;"><span>Image resized.
</span></span></code></pre></div><p>When inspecting the new disk image, we see the new capacity is 2MB but the file size on disk is under 200KB.  This is because qcow2 supports
copy-on-write and compression.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img info my_disk.img
</span></span><span style="display:flex;"><span>image: my_disk.img
</span></span><span style="display:flex;"><span>file format: qcow2
</span></span><span style="display:flex;"><span>virtual size: <span style="color:#ae81ff">2</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">2097152</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: <span style="color:#ae81ff">196</span> KiB
</span></span><span style="display:flex;"><span>cluster_size: <span style="color:#ae81ff">65536</span>
</span></span><span style="display:flex;"><span>Format specific information:
</span></span><span style="display:flex;"><span>    compat: 1.1
</span></span><span style="display:flex;"><span>    compression type: zlib
</span></span><span style="display:flex;"><span>    lazy refcounts: false
</span></span><span style="display:flex;"><span>    refcount bits: <span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>    corrupt: false
</span></span><span style="display:flex;"><span>    extended l2: false
</span></span><span style="display:flex;"><span>Child node <span style="color:#e6db74">&#39;/file&#39;</span>:
</span></span><span style="display:flex;"><span>    filename: my_disk.img
</span></span><span style="display:flex;"><span>    protocol type: file
</span></span><span style="display:flex;"><span>    file length: <span style="color:#ae81ff">192</span> KiB <span style="color:#f92672">(</span><span style="color:#ae81ff">197120</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    disk size: <span style="color:#ae81ff">196</span> KiB
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% ls -lh my_disk.img 
</span></span><span style="display:flex;"><span>-rw-r--r--  <span style="color:#ae81ff">1</span> adam  staff   192K Apr  <span style="color:#ae81ff">6</span> 10:19 my_disk.img
</span></span></code></pre></div><p>If I were to resize a QEMU storage file formatted as raw, the file size on disk of 2MB matches the image capacity of 2MB as raw
doesn&rsquo;t support compression or copy-on-write.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img create raw_disk.img +2m
</span></span><span style="display:flex;"><span>Formatting <span style="color:#e6db74">&#39;raw_disk.img&#39;</span>, fmt<span style="color:#f92672">=</span>raw size<span style="color:#f92672">=</span><span style="color:#ae81ff">2097152</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% ls -lh raw_disk.img 
</span></span><span style="display:flex;"><span>-rw-r--r--  <span style="color:#ae81ff">1</span> adam  staff   2.0M Apr  <span style="color:#ae81ff">6</span> 10:22 raw_disk.img
</span></span></code></pre></div><h1 id="tip-two---snapshots">Tip Two - Snapshots</h1>
<p>Snapshots are supported with qcow2 devices.  These are handy for creating a base disk image that&rsquo;s shareable and later modified
for other purposes.  Snapshots also make a great backup point before making image changes.</p>
<p>To create a snapshot named &ldquo;my_first_snapshot&rdquo; inside an existing qcow2 image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img snapshot -c my_first_snapshot my_disk.img 
</span></span></code></pre></div><p>To list existing snapshots</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img snapshot -l my_disk.img 
</span></span><span style="display:flex;"><span>Snapshot list:
</span></span><span style="display:flex;"><span>ID      TAG               VM_SIZE                DATE        VM_CLOCK     ICOUNT
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>       my_first_snapshot      <span style="color:#ae81ff">0</span> B 2025-04-06 10:37:07  0000:00:00.000          <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>To revert or &ldquo;apply&rdquo; a snapshot</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img snapshot -a my_first_snapshot my_disk.img 
</span></span></code></pre></div><p>To delete a snapshot from a file</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img snapshot -d my_first_snapshot my_disk.img 
</span></span></code></pre></div><h1 id="tip-three---modify-a-qemu-image">Tip Three - Modify a QEMU image</h1>
<p>While many online guides suggest using the Network Block Device (NBD) kernel driver in Linux to mount and modify QEMU images, I
use a different process that also works on MacOS.  My preferred method is to boot a VM using QEMU and attaching the image as a data drive.</p>
<p>This example uses the <a href="https://dl-cdn.alpinelinux.org/alpine/v3.21/releases/x86_64/alpine-extended-3.21.3-x86_64.iso">extended x86_64 Alpine Linux ISO</a>
and a QEMU command that mounts the image as a data drive.  The Alpine extended ISO lets you log in as root with an empty password,
which makes quick edits easy.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#/bin/sh</span>
</span></span><span style="display:flex;"><span>qemu-system-x86_64 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -m 2G -smp cpus<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> -serial stdio <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -boot once<span style="color:#f92672">=</span>d  <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -drive file<span style="color:#f92672">=</span>./my_disk.img,format<span style="color:#f92672">=</span>qcow2,media<span style="color:#f92672">=</span>disk,cache<span style="color:#f92672">=</span>unsafe <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -drive file<span style="color:#f92672">=</span>./alpine-extended-3.21.2-x86_64.iso,format<span style="color:#f92672">=</span>raw,media<span style="color:#f92672">=</span>cdrom <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -nic user,model<span style="color:#f92672">=</span>virtio-net-pci,hostfwd<span style="color:#f92672">=</span>tcp::2222-:22
</span></span></code></pre></div><p>Once logged in, you&rsquo;ll see the QEMU file we want to modify listed as /dev/sda.  The device hasn&rsquo;t been formatted with a filesystem, but if
one were present it could be mounted within the VM, files edited within the image, and then unmounted.</p>
<h1 id="tip-four---transfer-a-qemu-image-to-bare-metal">Tip Four - Transfer a QEMU image to bare-metal</h1>
<p>It&rsquo;s possible to use a QEMU image with bare-metal by converting it to <strong>raw</strong> format.  Use the following to convert the image from qcow2 to raw.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img convert -f qcow2 -O raw my_disk.img raw_disk.img
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% qemu-img info raw_disk.img 
</span></span><span style="display:flex;"><span>image: raw_disk.img
</span></span><span style="display:flex;"><span>file format: raw
</span></span><span style="display:flex;"><span>virtual size: <span style="color:#ae81ff">10</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">10485760</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: <span style="color:#ae81ff">10</span> MiB
</span></span><span style="display:flex;"><span>Child node <span style="color:#e6db74">&#39;/file&#39;</span>:
</span></span><span style="display:flex;"><span>    filename: raw_disk.img
</span></span><span style="display:flex;"><span>    protocol type: file
</span></span><span style="display:flex;"><span>    file length: <span style="color:#ae81ff">10</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">10485760</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    disk size: <span style="color:#ae81ff">10</span> MiB
</span></span></code></pre></div><p>Once we have the raw image, the <strong>dd</strong> command can be used to write the data to either a USB stick or physical SSD.  To avoid
any destructive commands let&rsquo;s pretend raw_disk2.img represents /dev/sdc, your verified USB thumb drive.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>raw_disk.img of<span style="color:#f92672">=</span>raw_disk2.img bs<span style="color:#f92672">=</span>1m 
</span></span><span style="display:flex;"><span>10+0 records in
</span></span><span style="display:flex;"><span>10+0 records out
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10485760</span> bytes transferred in 0.006266 secs <span style="color:#f92672">(</span><span style="color:#ae81ff">1673437600</span> bytes/sec<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>Because our raw file is only 10MB in size, only 10MB will be used on the thumb drive.  This is where follow up tools like LVM or
resize2fs will extend the filesystem to fill the entire thumb drive.  Tools used for expansion depends on how the filesystem was created.</p>
<h1 id="putting-it-all-together">Putting it all together</h1>
<p>Enough with the documentation, let&rsquo;s put it into practice with a real use case.  Presume that after reading my <a href="../../../articles/cloudinit/intro/">cloud-init
tutorials</a> you wish to modify the <a href="https://dl-cdn.alpinelinux.org/alpine/v3.21/releases/cloud/nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2">Alpine Linux cloud-init image</a> before installation.</p>
<p>We can see the downloaded file is a qcow2 image with a capacity of 200Mb from <strong>qemu-img info</strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span> % qemu-img info nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 
</span></span><span style="display:flex;"><span>image: nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2
</span></span><span style="display:flex;"><span>file format: qcow2
</span></span><span style="display:flex;"><span>virtual size: <span style="color:#ae81ff">200</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">209715200</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: <span style="color:#ae81ff">181</span> MiB
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>As we want to install our java app into the installer, we need to add space to the image with <strong>qemu-img resize</strong>.  But first,
let’s create a snapshot. That way, if we make a mistake, we won’t need to re-download the cloud-init image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img snapshot -c no_modifications nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% qemu-img resize nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 +800M
</span></span><span style="display:flex;"><span>Image resized.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> % qemu-img info nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2        
</span></span><span style="display:flex;"><span>image: nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2
</span></span><span style="display:flex;"><span>file format: qcow2
</span></span><span style="display:flex;"><span>virtual size: 0.977 GiB <span style="color:#f92672">(</span><span style="color:#ae81ff">1048576000</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: <span style="color:#ae81ff">197</span> MiB
</span></span><span style="display:flex;"><span>cluster_size: <span style="color:#ae81ff">65536</span>
</span></span><span style="display:flex;"><span>Snapshot list:
</span></span><span style="display:flex;"><span>ID      TAG               VM_SIZE                DATE        VM_CLOCK     ICOUNT
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>       no_modifications      <span style="color:#ae81ff">0</span> B 2025-04-06 15:23:50  0000:00:00.000          <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>Format specific information:
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>I&rsquo;m still using the Alpine extended ISO to boot the VM. Alpine cloud images require setup for ssh key authentication to login and an
empty root password is much easier to use.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-system-x86_64 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -m 2G -smp cpus<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> -serial stdio <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -boot once<span style="color:#f92672">=</span>d  <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -drive file<span style="color:#f92672">=</span>./nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2,format<span style="color:#f92672">=</span>qcow2,media<span style="color:#f92672">=</span>disk,cache<span style="color:#f92672">=</span>unsafe <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -drive file<span style="color:#f92672">=</span>./alpine-extended-3.21.2-x86_64.iso,format<span style="color:#f92672">=</span>raw,media<span style="color:#f92672">=</span>cdrom <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -nic user,model<span style="color:#f92672">=</span>virtio-net-pci,hostfwd<span style="color:#f92672">=</span>tcp::2222-:22
</span></span></code></pre></div><p>Login as root and mount the disk device under /mnt</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>localhost:~# mount /dev/sda /mnt 
</span></span><span style="display:flex;"><span>localhost:~# ls /mnt
</span></span><span style="display:flex;"><span>bin         home        mnt         run         tmp
</span></span><span style="display:flex;"><span>boot        lib         opt         sbin        usr
</span></span><span style="display:flex;"><span>dev         lost+found  proc        srv         var
</span></span><span style="display:flex;"><span>etc         media       root        sys
</span></span></code></pre></div><p>Then make changes to the cloud image, unmount the filesystem and you&rsquo;re done.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>localhost:~# echo <span style="color:#e6db74">&#34;Adam Faris was here&#34;</span> &gt; /mnt/etc/motd 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>localhost:~# cat /mnt/etc/motd 
</span></span><span style="display:flex;"><span>Adam Faris was here
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>localhost:~# umount /mnt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>localhost:~# poweroff
</span></span></code></pre></div><p>Finally, convert our modified cloud image from qcow2 format to raw format, then use dd to write the raw image to a USB device.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img convert -f qcow2 -O nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 alpine_cloudinit.raw
</span></span><span style="display:flex;"><span>% dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>alpine_cloudinit.raw bs<span style="color:#f92672">=</span>1m of<span style="color:#f92672">=</span>/dev/...
</span></span></code></pre></div><p>With the modified image written to the USB device, you can now boot a physical machine from it. Thanks for sticking with me until
the end. If you find this content useful, follow me on <a href="https://bsky.app/profile/af9.us">BlueSky social</a> for future announcements.</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
