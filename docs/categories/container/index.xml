<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Container on Adam Faris</title>
    <link>https://amf3.github.io/categories/container/</link>
    <description>Recent content in Container on Adam Faris</description>
    <generator>Hugo -- 0.152.2</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Feb 2026 16:29:59 -0800</lastBuildDate>
    <atom:link href="https://amf3.github.io/categories/container/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Open Container Image Format</title>
      <link>https://amf3.github.io/articles/virtualization/oci_image/</link>
      <pubDate>Mon, 23 Feb 2026 16:29:59 -0800</pubDate>
      <guid>https://amf3.github.io/articles/virtualization/oci_image/</guid>
      <description>From Local TAR file to Open Container Image</description>
      <content:encoded><![CDATA[<p><img alt="Image of shipping containers on the pier" loading="lazy" src="/articles/virtualization/oci_image/assets/containers.jpg"></p>
<p>Forget about needing Docker&rsquo;s buildx or Redhat&rsquo;s buildah for this OCI container image deep dive. I will explain the OCI container image
model and demonstrate building a new container image with a little JSON and a few SHA256 hash sums.  You will understand that container images
aren&rsquo;t a file you download, but instead a graph of nodes and how the nodes are addressed after reading this article.</p>
<h2 id="the-build-artifact">The Build Artifact</h2>
<p>A build artifact is the reproducible output created after building an application. The artifact is complete and contains all neccessary
directories, compiled binaries, configs, libraries, and a directory structure.  Often this is packged as a tar archive (tar) or zip file,
but isn&rsquo;t a requriement.  The artifact contains everything needed for the application to execute in its intended environment, (arm, x86, linux,
windows).  There are no container specific files within the artifact, it&rsquo;s just a directory tree of files.</p>
<p>Convention refers to the directory tree as a <strong>root filesystem</strong> when working with container images.  This is due to the
directory tree being mounted at / inside the container.  The root fs is not a block device filesystem like ext4.</p>
<h2 id="oci-container-image-description">OCI Container Image Description</h2>
<p>A container image consists of a root filesystem and a set of JSON documents describing how the filesystem should be used.
Each component of the image is stored as a content addressible blob, identified by the SHA256 hash of the blobs contents.  Because identity is
derived from content, any modification produces a new digest and a new image identitify instead of mutating the existing image.</p>
<p>The image contains a manifest file which ties the blobs together.  The manifest references the filesystem layers and configuration file by
their SHA256 digests.  The configuration file defines how to run the filesystem as a container by listing what process to start, the target
operating system, CPU architecture, environment variables, working directory and other execution settings.</p>
<p>Additional metadata can be associated with an image after its created, like a Software Bill of Materials. This is done by publishing a
seperate artifact that references the images manifest digest.  Associating metadata by reference keeps the original image unchanged.</p>
<p>Because a container image is composed of multiple content addressible blobs connected by digest references, it does not exist as a single
downloadable file.  Instead a container image forms a directed graph of nodes, a manifest pointing to configuration and layer blobs, and
potentially additional artifacts pointing back to the manifest. Container tooling understands how to traverse this graph and retrieve the
referenced content.</p>
<h2 id="elements-of-a-oci-container-image">Elements of a OCI Container Image</h2>
<p>When stored on disk, the graph of object addressable objects is represented using a
<a href="https://github.com/opencontainers/image-spec/blob/main/image-layout.md">standard layout</a>. The layout stores objects by hash and the
JSON descriptors define the edges between those objects. Each object is stored under <code>blobs/&lt;algorithm&gt;/&lt;digest&gt;</code>, where the filename is the
cryptographic hash of its contents. If the contents change, the filename must change.</p>
<pre tabindex="0"><code>.
├── blobs
│   └── sha256
│       ├── 17eec7bbc9d79fa397ac95c7283ecd04d1fe6978516932a3db110c6206430809
│       ├── 1b44b5a3e06a9aae883e7bf25e45c100be0bb81a0e01b32de604f3ac44711634
│       └── 2771e37a12b7bcb2902456ecf3f29bf9ee11ec348e66e8eb322d9780ad7fc2df
├── index.json
└── oci-layout
</code></pre><p>The <code>oci-layout</code> file declares that the top level directory follows the OCI Image Layout specification and indicates the layout version.</p>
<pre tabindex="0"><code>{
    &#34;imageLayoutVersion&#34;: &#34;1.0.0&#34;
}
</code></pre><p>The <code>index.json</code> file is the entry point of the container image and the root of the graph. The <strong>tag</strong> &ldquo;latest&rdquo;
(&ldquo;org.opencontainers.image.ref.name&rdquo;: &ldquo;latest&rdquo;) is mapped to a specific digest
(digest&quot;: &ldquo;sha256:2771e37a12b7bcb2902456ecf3f29bf9ee11ec348e66e8eb322d9780ad7fc2df&rdquo;) that is marked as the <strong>manifest</strong>
(&ldquo;mediaType&rdquo;: &ldquo;application/vnd.oci.image.manifest.v1+json&rdquo;).</p>
<pre tabindex="0"><code>{
  &#34;schemaVersion&#34;: 2,
  &#34;manifests&#34;: [
    {
      &#34;mediaType&#34;: &#34;application/vnd.oci.image.manifest.v1+json&#34;,
      &#34;digest&#34;: &#34;sha256:2771e37a12b7bcb2902456ecf3f29bf9ee11ec348e66e8eb322d9780ad7fc2df&#34;,
      &#34;size&#34;: 1035,
      &#34;annotations&#34;: {
        &#34;org.opencontainers.image.ref.name&#34;: &#34;latest&#34;
      }
    }
  ]
}
</code></pre><p>The <code>manifest</code> at blobs/sha256/2771e&hellip;c2df declares the
image configuration and the
ordered set of filesystem layers. This example contains a single filesystem layer.  In general, the
<strong>layers</strong> array can contain multiple entries, which are applied in order to construct the root
filesystem.</p>
<pre tabindex="0"><code>{
  &#34;schemaVersion&#34;: 2,
  &#34;mediaType&#34;: &#34;application/vnd.oci.image.manifest.v1+json&#34;,
  &#34;config&#34;: {
    &#34;mediaType&#34;: &#34;application/vnd.oci.image.config.v1+json&#34;,
    &#34;digest&#34;: &#34;sha256:1b44b5a3e06a9aae883e7bf25e45c100be0bb81a0e01b32de604f3ac44711634&#34;,
    &#34;size&#34;: 547
  },
  &#34;layers&#34;: [
    {
      &#34;mediaType&#34;: &#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;,
      &#34;digest&#34;: &#34;sha256:17eec7bbc9d79fa397ac95c7283ecd04d1fe6978516932a3db110c6206430809&#34;,
      &#34;size&#34;: 2380
    }
  ],
...
</code></pre><p>The trust chain is explicit with a container image. The entry point, index.json, selects a
<a href="https://github.com/opencontainers/image-spec/blob/main/media-types.md">manifest by digest</a>. The
manifest selects its config and ordered filesystem layers by digest. The filename of each object under
blobs/sha256 must match its contents hash.</p>
<p>When selecting an image by tag, we are unknowingly selecting by digest.  While tags are mutable references, digests are not. This is why the
tag &ldquo;latest&rdquo; can reference a different digest then the one currently in use.</p>
<h2 id="oci-container-image-demo">OCI Container Image Demo</h2>
<p>We will construct an OCI container image manually to demonstrate that an image consists only of content addressed blobs and a few
JSON documents.  This is not a production workflow. The goal is to expose the model, not replace existing tooling.  Because higher
level objects reference lower level objects by digest, construction begins with the leaves of the graph. Any modification
to an object would change the layer digest, which would in turn invalidate the config and manifest digests above it.</p>
<p>Begin with creating a staging directory for building our conatiner image and the compiled application.  The application is statically
compiled and named <strong>hello</strong>. It prints a greeting defined by the <a href="./assets/hello.go">GREETING</a> environment variable, else it prints &ldquo;Hello World&rdquo;.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ mkdir -p myapp/blobs/sha256
</span></span><span style="display:flex;"><span>$ tree myapp
</span></span><span style="display:flex;"><span>myapp
</span></span><span style="display:flex;"><span>└── blobs
</span></span><span style="display:flex;"><span>    └── sha256
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ ./build/hello 
</span></span><span style="display:flex;"><span>HELLO WORLD!!!
</span></span><span style="display:flex;"><span>$ GREETING<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;HELLO ADAM&#34;</span> ./build/hello 
</span></span><span style="display:flex;"><span>HELLO ADAM
</span></span></code></pre></div><p>Next turn the &ldquo;hello&rdquo; application into a root filesystem blob.  Currently the build artifact is in the &ldquo;./build&rdquo; directory which
gets archived with tar.  Compute the SHA256 digest on the tar archive and the archive is copied to the staging directory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ tree build/
</span></span><span style="display:flex;"><span>build/
</span></span><span style="display:flex;"><span>└── hello
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ tar --numeric-owner --owner<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> --group<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -cf layer.tar -C build .
</span></span><span style="display:flex;"><span>$ sha256sum layer.tar 
</span></span><span style="display:flex;"><span>0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb  layer.tar
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ cp layer.tar myapp/blobs/sha256/0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ tree myapp/
</span></span><span style="display:flex;"><span>myapp/
</span></span><span style="display:flex;"><span>└── blobs
</span></span><span style="display:flex;"><span>    └── sha256
</span></span><span style="display:flex;"><span>        └── 0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb
</span></span></code></pre></div><p>Create a config object which tells the container runtime how to execute the filesystem. For simplicity this example uses an uncompressed tar
archive. The diff_ids value matches the layer digest.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ cat config.json 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;architecture&#34;</span>: <span style="color:#e6db74">&#34;amd64&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;os&#34;</span>: <span style="color:#e6db74">&#34;linux&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;config&#34;</span>: <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Env&#34;</span>: <span style="color:#f92672">[]</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Entrypoint&#34;</span>: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/hello&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;rootfs&#34;</span>: <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;layers&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;diff_ids&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;sha256:0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ sha256sum config.json
</span></span><span style="display:flex;"><span>f86f75f0d7a7dd4c951a158aca51894ab59f46b0348558a341a589bfcc0d253c  config.json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ cp config.json myapp/blobs/sha256/f86f75f0d7a7dd4c951a158aca51894ab59f46b0348558a341a589bfcc0d253c
</span></span></code></pre></div><p>The manifest binds the configuration and layer digests into a single image descriptor. The manifest
file also gets hashed and stored in the staging directory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ cat manifest 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schemaVersion&#34;</span>: 2,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;mediaType&#34;</span>: <span style="color:#e6db74">&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;config&#34;</span>: <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;mediaType&#34;</span>: <span style="color:#e6db74">&#34;application/vnd.oci.image.config.v1+json&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;digest&#34;</span>: <span style="color:#e6db74">&#34;sha256:f86f75f0d7a7dd4c951a158aca51894ab59f46b0348558a341a589bfcc0d253c&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;size&#34;</span>: <span style="color:#ae81ff">255</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;layers&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;mediaType&#34;</span>: <span style="color:#e6db74">&#34;application/vnd.oci.image.layer.v1.tar&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;digest&#34;</span>: <span style="color:#e6db74">&#34;sha256:0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;size&#34;</span>: <span style="color:#ae81ff">1914880</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ sha256sum manifest
</span></span><span style="display:flex;"><span>d6fceb45932ad49b50f9a1e24b21691b60f861bf46ed9e4a47bd74b8401a2ecd  manifest
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ cp manifest myapp/blobs/sha256/d6fceb45932ad49b50f9a1e24b21691b60f861bf46ed9e4a47bd74b8401a2ecd
</span></span></code></pre></div><p>Finally create the container entry point and declare the myapp directory is the top level directory of a OCI compliant image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ cat myapp/index.json
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schemaVersion&#34;</span>: 2,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;manifests&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;mediaType&#34;</span>: <span style="color:#e6db74">&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;digest&#34;</span>: <span style="color:#e6db74">&#34;sha256:d6fceb45932ad49b50f9a1e24b21691b60f861bf46ed9e4a47bd74b8401a2ecd&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;size&#34;</span>: 476,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;annotations&#34;</span>: <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;org.opencontainers.image.ref.name&#34;</span>: <span style="color:#e6db74">&#34;latest&#34;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ cat myapp/oci-layout
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;imageLayoutVersion&#34;</span>: <span style="color:#e6db74">&#34;1.0.0&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>The image layout is now complete. We can import it into a runtime and execute it.</p>
<pre tabindex="0"><code>adam@charizard:~/foo/demo$ skopeo copy oci:./myapp docker-daemon:myapp:latest
Getting image source signatures
Copying blob 0f11da71a27a done   | 
Copying config f86f75f0d7 done   | 
Writing manifest to image destination

$ docker run --rm myapp:latest 
HELLO WORLD!!!
$ docker run --rm -e GREETING=&#34;Hello OCI image&#34; myapp:latest 
Hello OCI image
</code></pre><h2 id="why-the-model-matters">Why the Model Matters</h2>
<p>Understanding that a container image is a graph of content addressible blobs isn&rsquo;t trivia.  You gain several advantages when you stop seeing the image as a &ldquo;magic file&rdquo; and start seeing it
as a verifiable manifest.</p>
<p><strong>Tooling:</strong> Stop worrying about whether Docker is better than Podman. They are just different UI wrappers for the same OCI specification. Tooling becomes an implementation detail.</p>
<p><strong>Debugging:</strong> When an image is bloated or a layer is flagged by a security scanner, you don&rsquo;t need specialized tools to tell you why.  By inspecting the graph, you can identify exactly which
object introduced the content and then inspect that specific content.</p>
<p><strong>Supply Chain Confidence:</strong> By understanding that identity is derived from content you can verify image integrity or attach metadata (like SBOMs) with
confidence, knowing that objects bind to the manifest digest.</p>
<h2 id="closing">Closing</h2>
<p>My next article will use these principals in constructing a minimal distroless image without using a base image or package manager. Reach out on
<a href="https://bsky.app/profile/af9.us">BlueSky social</a> to let me know if these topics are useful or interesting.</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
