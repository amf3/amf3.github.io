<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Operations on Adam Faris</title>
    <link>https://amf3.github.io/categories/operations/</link>
    <description>Recent content in Operations on Adam Faris</description>
    <generator>Hugo -- 0.152.2</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 21 Mar 2025 16:28:54 -0400</lastBuildDate>
    <atom:link href="https://amf3.github.io/categories/operations/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>cloud-init troubleshooting</title>
      <link>https://amf3.github.io/articles/cloudinit/troubleshooting/</link>
      <pubDate>Fri, 21 Mar 2025 16:28:54 -0400</pubDate>
      <guid>https://amf3.github.io/articles/cloudinit/troubleshooting/</guid>
      <description>A simple workflow in resolving cloud-init deployment problems.</description>
      <content:encoded><![CDATA[<p>I previously wrote an <a href="../../../articles/cloudinit/intro/">introduction</a> to cloud-init. I&rsquo;d like to now follow up with a discussion on
troubleshooting. cloud-init failures on remote hosts can be challenging. Depending on the failure point, cloud-init may or may not
provide clear error indicators.  These are methods I use during provisioning issues related to cloud-init.</p>
<h1 id="understanding-cloud-init-execution-stages">Understanding cloud-init execution stages</h1>
<p>Before continuing, let&rsquo;s cover some background.  cloud-init follows
<a href="https://cloudinit.readthedocs.io/en/latest/explanation/boot.html">five stages</a> during boot which run sequentially. If
a stage completes, output will contain a status that can be used to verify that stage was successful.</p>
<p><strong>Detect stage:</strong> The init system is responsible for calling
<a href="https://github.com/canonical/cloud-init/blob/main/tools/ds-identify">ds_identify</a> to determine whether cloud-init
should run.  With systemd hosts, this is implemented as a systemd generator.</p>
<p><strong>Local stage:</strong> Identifies local resources that are available without network access. Configures networking, which if unsuccessful
falls back to DHCP.</p>
<p><strong>Network stage:</strong> Retrieves user-data, sets up disk partitions, and mounts the filesystem.  When complete, serial console or SSH access
should become available.</p>
<p><strong>Config stage:</strong> Runs configuration modules and executes commands specified in user-data.</p>
<p><strong>Final stage:</strong> Installs packages, applies configuration management plugins like puppet or chef, and runs user or vendor defined scripts.</p>
<h1 id="checking-stage-status">Checking Stage Status</h1>
<p>The <strong>status</strong> submenu from the cloud-init command provides a method of checking each stage for errors.  In this
example I intentionally mistyped a schema key name that should be <code>passwd</code> as <code>password</code>.  Output shows the failure
occurred during the init stage &amp; provides a suggestion on how to resolve it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ cloud-init status --format json
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;extended_status&#34;</span>: <span style="color:#e6db74">&#34;degraded done&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;init&#34;</span>: <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;errors&#34;</span>: <span style="color:#f92672">[]</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;finished&#34;</span>: 6.52,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;recoverable_errors&#34;</span>: <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;WARNING&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;cloud-config failed schema validation! You may run &#39;sudo cloud-init schema --system&#39; to check the details.&#34;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>,
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;status&#34;</span>: <span style="color:#e6db74">&#34;done&#34;</span>
</span></span></code></pre></div><h1 id="checking-logs-for-errors">Checking logs for Errors</h1>
<p>When the issue is not obvious, there logs are available for further examination.</p>
<ul>
<li>/var/log/cloud-init.log  (execution details and errors)</li>
<li>/var/log/cloud-init-output.log  (captured output from executed commands)</li>
<li>/run/cloud-init/result.json  (summary of execution status)</li>
</ul>
<p>Example log output from cloud-init.log indicating a schema validation failure.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>2025-03-18 11:46:41,379 - schema.py<span style="color:#f92672">[</span>WARNING<span style="color:#f92672">]</span>: cloud-config failed schema validation! You may run <span style="color:#e6db74">&#39;sudo cloud-init schema --system&#39;</span> to check the details.
</span></span></code></pre></div><h1 id="debugging-user-data-issues">Debugging User-Data Issues</h1>
<p>cloud-init has a defined schema and it’s possible to validate user-data content with the <strong>schema</strong> submenu.
To troubleshoot a possible schema issue on a remote host where a YAML key named <code>passwd</code> was mistyped as <code>password</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ sudo cloud-init schema --system
</span></span><span style="display:flex;"><span>Found cloud-config data types: user-data, vendor-data, network-config
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>1. user-data at /var/lib/cloud/instances/docker-demo/cloud-config.txt:
</span></span><span style="display:flex;"><span>  Invalid user-data /var/lib/cloud/instances/docker-demo/cloud-config.txt
</span></span><span style="display:flex;"><span>  Error: Cloud config schema errors: users.0: Additional properties are not allowed <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;password&#39;</span> was unexpected<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>…
</span></span><span style="display:flex;"><span>Error: Invalid schema: user-data
</span></span></code></pre></div><p>To test changes made to user-data content prior to provisioning: <code>cloud-init schema -c “my_user_data_file.yaml”</code>.</p>
<p>For timeout issues in user or vendor scripts, <code>cloud-init analyze</code> will print execution times which pinpoint delays.</p>
<h1 id="common-failure-scenarios-and-fixes">Common Failure Scenarios and Fixes</h1>
<p>A typical source of failures is from syntax errors in the user-data file.  As already mentioned, <code>cloud-init schema</code> will
show schema issues in user-data.  Manually check for typos within the values in user-data. A mistyped value is
still a string and can pass the schema validation.</p>
<p>Another possible issue is misconfigured network settings preventing package installation.  Ensure package mirrors are reachable
and contain the package.  The <strong>cloud-init-output.log</strong> file can show additional hints related to package failures.  If SSH is unavailable,
try accessing the instance over the instance&rsquo;s serial console.</p>
<p>Check for missing or incorrectly set permissions on scripts.</p>
<p>Use <code>cloud-init analyze show</code> to help in identifying long-running stages.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ cloud-init analyze show
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>-- Boot Record <span style="color:#ae81ff">01</span> --
</span></span><span style="display:flex;"><span>The total time elapsed since completing an event is printed after the <span style="color:#e6db74">&#34;@&#34;</span> character.
</span></span><span style="display:flex;"><span>The time the event takes is printed after the <span style="color:#e6db74">&#34;+&#34;</span> character.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Starting stage: init-local
</span></span><span style="display:flex;"><span>|<span style="color:#e6db74">`</span>-&gt;no cache found @00.00100s +00.00000s
</span></span><span style="display:flex;"><span>|<span style="color:#e6db74">`</span>-&gt;found local data from DataSourceNoCloud @00.00400s +00.01500s
</span></span><span style="display:flex;"><span>Finished stage: <span style="color:#f92672">(</span>init-local<span style="color:#f92672">)</span> 00.28900 seconds
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Starting stage: init-network
</span></span><span style="display:flex;"><span>|<span style="color:#e6db74">`</span>-&gt;restored from cache with run check: DataSourceNoCloud <span style="color:#f92672">[</span>seed<span style="color:#f92672">=</span>/dev/vda<span style="color:#f92672">]</span> @02.56800s +00.00100s
</span></span><span style="display:flex;"><span>|<span style="color:#e6db74">`</span>-&gt;setting up datasource @02.57600s +00.00000s
</span></span><span style="display:flex;"><span>|<span style="color:#e6db74">`</span>-&gt;reading and applying user-data @02.58000s +00.00200s
</span></span><span style="display:flex;"><span>|<span style="color:#e6db74">`</span>-&gt;reading and applying vendor-data @02.58200s +00.00200s
</span></span><span style="display:flex;"><span>|<span style="color:#e6db74">`</span>-&gt;reading and applying vendor-data2 @02.58400s +00.00000s
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><h1 id="recovery-and-re-runs">Recovery and Re-Runs</h1>
<p>Additional steps are needed after modifying user-data files on the failed instance. When cloud-init runs, output is
cached to disk.  If the cache exists on reboot, cloud-init will not run again.  To clean cached instance data,
run <code>cloud-init clean --logs</code> and reboot the instance.</p>
<p>Issues with a specific module can be exposed by using <code>cloud-init single</code>.  This could be useful when
troubleshooting user or vendor scripts.  Module names can be found with <code>grep &quot;Running module&quot; /var/log/cloud-init.log</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ sudo cloud-init single --name set_passwords
</span></span><span style="display:flex;"><span>Cloud-init v. 24.4.1-0ubuntu0~24.04.1 running <span style="color:#e6db74">&#39;single&#39;</span> at Fri, <span style="color:#ae81ff">21</span> Mar <span style="color:#ae81ff">2025</span> 20:45:47 +0000. Up 16145.16 seconds.
</span></span></code></pre></div><p>When using the <strong>single</strong> submenu, it won&rsquo;t necessarily fix dependencies unless those are also explicitly re-triggered.  It&rsquo;s best
to reprovision the instance after troubleshooting any failed modules.</p>
<h1 id="takeaways">Takeaways</h1>
<p>There’s no simple fix for understanding why instance provisioning with cloud-init failed.  That’s why I’m
closing with a checklist.</p>
<ul>
<li>Check cloud-init status
<ul>
<li>Use <code>cloud-init status --long</code> (or &ndash;json) for execution state</li>
<li>Use <code>cloud-init analyze</code> for timing analysis</li>
</ul>
</li>
<li>Inspect logs for errors
<ul>
<li>/var/log/cloud-init.log: Shows errors and execution order</li>
<li>/var/log/cloud-init-output.log: contains command output</li>
</ul>
</li>
<li>Validate user-data input
<ul>
<li><code>cloud-init schema</code> to validate syntax</li>
<li>Ensure values are correct and not only properly formatted YAML</li>
</ul>
</li>
<li>Check for missing dependencies or network issues
<ul>
<li>Ensure package mirrors are available and contain the necessary packages.</li>
<li>Verify custom scripts are executable.</li>
</ul>
</li>
<li>Re-run cloud-init if needed.
<ul>
<li>Clean logs and reset cloud-init: <code>cloud-init clean --logs</code> &amp;&amp; reboot</li>
<li>Manually rerun a failed module: <code>cloud-init single -n “some_module_name”</code></li>
</ul>
</li>
</ul>
<p>Happy provisioning, and follow me on <a href="https://bsky.app/profile/af9.us">Bluesky</a> if you find content like this interesting.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Unattended Ubuntu Installs - Virtual Machines to Bare-Metal</title>
      <link>https://amf3.github.io/articles/cloudinit/autoinstall/</link>
      <pubDate>Mon, 03 Mar 2025 23:07:23 -0800</pubDate>
      <guid>https://amf3.github.io/articles/cloudinit/autoinstall/</guid>
      <description>Using cloud-init to deploy Linux on either bare-metal or virtual machines</description>
      <content:encoded><![CDATA[<p>In a <a href="../../../articles/cloudinit/intro/">previous post</a>, I discussed using cloud-init and Multipass as a method of provisioning
virtual machines on a local computer with a cloud-like API.  Today I am going
to dive deeper with Ubuntu and how their autoinstall API can simplify on-premise host provisioning.</p>
<p><a href="https://canonical-subiquity.readthedocs-hosted.com/en/latest/intro-to-autoinstall.html">autoinstall</a>
is a tool that allows for unattended installations of Ubuntu, ensuring consistency, reporducibility, and providing automation
across a fleet of hosts.  In this post I&rsquo;ll walk through an example of using autoinstall
to configure networking, local storage, and demonstrate shell command execution during provisioning.</p>
<h2 id="prerequisite">Prerequisite</h2>
<p>Because the final target is a bare-metal instance, I find it quicker to iterate &amp; test autoinstall changes with
QEMU on my macOS M2 laptop.  QEMU is a hardware emulator
which runs on Linux, macOS, &amp; Windows, allowing the emulation of different CPUs, network cards, or storage devices.
Instructions to <a href="https://www.qemu.org/download/#macos">install QEMU</a> can be found online.  For macOS, this can be as simple as
running <code>brew install qemu</code>.</p>
<p>Next we need the Ubuntu install media which can be downloaded
<a href="https://ubuntu.com/download/server">here</a>.</p>
<h3 id="qemu-overview">QEMU overview</h3>
<p>Let&rsquo;s get started by creating a virtual disk drive for installing Ubuntu.  This can be done with
<code>qemu-img create -f qcow2 virtual_disk.img 6G</code> which creates a 6GB virtual disk named
virtual_disk.img in the current directory.</p>
<p>In the example below, the <code>-boot once=d</code> option instructes QEMU to boot from the virtual CD-ROM on first startup. After which QEMU will
boot from the virtual disk. The other options initialize a 4 core CPU with 4GB of memory.  The <code>-net user,hostfwd</code> string will
port forward from localhost on the host system to port 22 on the virtual machine.  If additional port forwarding is needed, like testing
https traffic on port 443 of the VM, multiple hostfwd options seperated by commas can used.  Be sure to adjust the filename and path to the Ubuntu ISO
as needed.</p>
<pre tabindex="0"><code class="language-code" data-lang="code">qemu-system-x86_64 -hda virtual_disk.img -boot once=d  -cdrom ./ubuntu-24.10-live-server-amd64.iso -m 4096 -smp cpus=4 -net nic,model=virtio -net user,hostfwd=tcp:127.0.0.1:2222-:22
</code></pre><h2 id="autoinstall">Autoinstall</h2>
<p>Autoinstall is included as part of the Ubuntu boot ISO and works with other provisioning tools from Canonical like
<a href="https://canonical-subiquity.readthedocs-hosted.com/en/latest/">Subiquity</a>,
<a href="https://curtin.readthedocs.io/en/latest/topics/overview.html">Curtin</a>, or <a href="https://cloudinit.readthedocs.io/en/latest/">cloud-init</a>.
When reading Autoinstall documentation, it&rsquo;s useful to know which tool is being used during each install stage as often those
options are passed to the underlying provisioning tool.</p>
<p>Like Kickstart for RHEL, Autoinstall is Ubuntu&rsquo;s answer to unattended
installations, and uses YAML files for data input.  Autoinstall uses default locations for finding the YAML files and locations
can also be specified in the GRUB menu when the instance boots.  Locations are specified as either a filepath or a URL.  I&rsquo;ll be
using a URL for the file locations.</p>
<p>Lets create the empty YAML files and use python to create a simple webserver to serve the files.  In another terminal type the following as the
webserver runs in the foreground.  Use cntl-c to terminate the python webserver when it&rsquo;s no longer needed.</p>
<pre tabindex="0"><code class="language-code" data-lang="code">touch user-data meta-data network-config vendor-data
python3 -m http.server -b 127.0.0.1 -d $PWD 8080
</code></pre><p>Next start the virtual machine.</p>
<pre tabindex="0"><code class="language-code" data-lang="code">qemu-system-x86_64 -hda virtual_disk.img -boot once=d  -cdrom ./ubuntu-24.10-live-server-amd64.iso -m 4096 -smp cpus=4 -net nic,model=virtio -net user,hostfwd=tcp:127.0.0.1:2222-:22
</code></pre><p>This will open a QEMU console window where we&rsquo;ll interact with the GRUB menu to specify the YAML file locations. Change focus to
the console window, highlight &ldquo;Try or Install Ubuntu Server&rdquo; and hit the <code>&quot;e&quot;</code> key to edit the grub menu.</p>
<p>On the line starting with “linux /casper/vmlinuz” add:  <code>autoinstall ds=nocloud\;s=http://10.0.2.2:8080/</code>  before
the three dashes.  The grub menu should look something like this when the edits are complete.</p>
<pre tabindex="0"><code class="language-code" data-lang="code">linux   /casper/vmlinuz autoinstall ds=nocloud\;s=http://10.0.2.2:8080/ ---
initrd  /casper/initrd  
</code></pre><p>Exit grub and boot by following the on-screen instructions to hit F10 or cntl-x.  Watch the terminal running the python webserver and
requests for the autoinstall YAML files should be seen.  As they are empty config files, an interactive menu-driven session will present itself
in the QEMU console window.  To cancel the install, close the QEMU console window.</p>
<p>The GRUB modification tells autoinstall to use the
<a href="https://cloudinit.readthedocs.io/en/latest/reference/datasources/nocloud.html">nocloud</a> plugin from cloud-init to download
its configuration at the specified URL.  QEMU assigns the special IP address of <code>10.0.2.2</code> to the host system when using <code>-net user</code>.  This allows the
VM to reach services running on the host such as our local Python HTTP server and why autoinstall is able to download its configurations over HTTP.</p>
<p>The YAML block should be added to the user-data file that was created earlier.  The other files will remain empty.
The <a href="https://github.com/canonical/subiquity/blob/main/doc/howto/autoinstall-quickstart.rst">minimal config example</a> assigns a
hostname of my-qemu-vm, creates an admin account named ubuntu, and assigns the ubuntu user the password of abc123.<br>
It&rsquo;s possible to generate a different secure password hash with openssl, as shown in
this example: <code>echo abc123 |  openssl passwd -6 -stdin</code>.  Restart the QEMU VM so it boots from the
virtual CD-ROM and modify the GRUB menu so it loads the new config when the VM boots.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">version</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">identity</span>:
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">hostname</span>: <span style="color:#ae81ff">my-qemu-vm</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">username</span>: <span style="color:#ae81ff">ubuntu</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">password</span>: <span style="color:#ae81ff">$6$xK2amorOU9tK4jt4$zLA1RZUpo4CzyDBzPDHCT61FLOngjWpV7Q/BH9KieLsJ/VG8r/Y88YIMLIOL.vc4ZHees40IAqORxjqa7GKti/</span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e"># password is &#34;abc123&#34;</span>
</span></span></code></pre></div><p>Autoinstall will take several minutes to complete and will reboot when done.  In some stages autoinstall can look stuck in some stages.
Remember that Linux virtual consoles are available to inspect running processes.  Virtual consoles are accessible by typing alt + left/right
arrow key or using alt + F2 or alt + F3.  (Use the option key for alt when using a Mac keyboard.)  Eventually the VM will reboot and the login
prompt should be visible if everything went as expected.</p>
<p>Autoinstall has a list of defaults it uses when the option is present in the user-data file.  After logging into the QEMU instance, it&rsquo;s
possible to view the specified values from the user-data YAML file that have been merged into the defaults.</p>
<pre tabindex="0"><code class="language-code" data-lang="code">sudo less /var/log/installer/autoinstall-user-data
</code></pre><p>Before continuing lets enable the ssh server, allow passwords for ssh login, and minimize the number of packages used during
the install.  Other options like locale or the keyboard setup can be found in the autoinstall-user-data file and added ot the example below.  Restarting
the QEMU VM and modifying the GRUB menu to reinstall the host OS is needed to apply the new changes to the YAML file.  Reinstalling
the OS also demonstrates the ease of initializing a system to a known state with autoinstall &amp; cloud-init configs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">version</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">identity</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">hostname</span>: <span style="color:#ae81ff">my-qemu-vm</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">username</span>: <span style="color:#ae81ff">ubuntu</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">password</span>: <span style="color:#ae81ff">$6$xK2amorOU9tK4jt4$zLA1RZUpo4CzyDBzPDHCT61FLOngjWpV7Q/BH9KieLsJ/VG8r/Y88YIMLIOL.vc4ZHees40IAqORxjqa7GKti/</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># password is &#34;abc123&#34;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">ssh</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># Install SSH server and allow password logins</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">allow-pw</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">install-server</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">source</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># id can also be ubuntu-server </span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">id</span>: <span style="color:#ae81ff">ubuntu-server-minimal</span>
</span></span></code></pre></div><h3 id="networking">Networking</h3>
<p>Both autoinstall and cloud-init support a netplan-formatted network configuration, meaning the YAML network example will work with
either installer.</p>
<p>Network device names are different between distributions that use Systemd (Ubuntu, Fedora) vs OpenRC (Alpine).  Where OpenRC
will use easily found device names like &ldquo;eth0&rdquo;, or &ldquo;eth1&rdquo;,
<a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.net-naming-scheme.html">Systemd</a> will use the PCI slot number.
A Systemd example might look like &ldquo;enp2s0&rdquo;, where &ldquo;en&rdquo; means ethernet, and &ldquo;p2s0&rdquo; is the
<a href="https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/">physical PCI slot</a>.
This value will change based on which slot a PCI card is plugged into.  Luckily
<a href="https://canonical-subiquity.readthedocs-hosted.com/en/latest/reference/autoinstall-reference.html#network">autoinstall</a>
lets us wildcard the device names.</p>
<p>This network example will work with either OpenRC or Systemd device names.  It&rsquo;s similar to what&rsquo;s used by
<a href="https://git.launchpad.net/livecd-rootfs/tree/live-build/ubuntu-server/includes.chroot.ubuntu-server-minimal.ubuntu-server.installer/etc/cloud/cloud.cfg#n23">Ubuntu&rsquo;s LiveCD</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">network</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">version</span>: <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ethernets</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">my-en-devices</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">match</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># This will match Systemd naming conventions for ethernet devices which start with &#34;en&#34; and set them to use DHCPv4</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">name</span>: <span style="color:#e6db74">&#34;en*&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">dhcp4</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">my-eth-devices</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">match</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># This will match OpenRC naming conventions like &#34;eth0&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">name</span>: <span style="color:#e6db74">&#34;eth*&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">addresses</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#75715e"># This will specify a static network address</span>
</span></span><span style="display:flex;"><span>          - <span style="color:#ae81ff">10.10.10.2</span><span style="color:#ae81ff">/24</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">nameservers</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#75715e"># We can modify the DNS search path &amp; specify DNS name servers.</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">search</span>:
</span></span><span style="display:flex;"><span>            - <span style="color:#e6db74">&#34;mycompany.local&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">addresses</span>:
</span></span><span style="display:flex;"><span>            - <span style="color:#ae81ff">10.10.10.253</span>
</span></span><span style="display:flex;"><span>            - <span style="color:#ae81ff">8.8.8.8</span>
</span></span></code></pre></div><h3 id="storage">Storage</h3>
<p>Configuring
<a href="https://canonical-subiquity.readthedocs-hosted.com/en/latest/reference/autoinstall-reference.html#storage">storage</a>
can be complex when configuring per partition byte offsets. Luckily we can provide a storage device name and let defaults
handle the details.  I&rsquo;ll show a basic lvm example but the other supported layouts are direct, and zfs.</p>
<p>Here we specify a LVM configuration with a sizing policy to use the entire disk for the logical volume.  If sizing-policy
were set to <code>scaled</code>, free space would be left on the storage device for things like snapshots or further expansion.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">storage</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">layout</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">lvm</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">sizing-policy</span>: <span style="color:#ae81ff">all</span>
</span></span></code></pre></div><p>Its possible to target a specific drive to wipe and install a new OS with a
<a href="https://canonical-subiquity.readthedocs-hosted.com/en/latest/reference/autoinstall-reference.html#disk-selection-extensions">match</a>
statement.  There are multiple ways to select a storage device, model name, serial number, path, whether
its rotational or not, or even big or little in size.  These values can be found in smartctl output, which
comes from the smartmontools package.</p>
<pre tabindex="0"><code class="language-code" data-lang="code">ubuntu@my-qemu-vm:~$ sudo apt-get install -y smartmontools
... install stuff ...

ubuntu@my-qemu-vm:~$ sudo smartctl -i /dev/sda
smartctl 7.4 2023-08-01 r5530 [x86_64-linux-6.11.0-18-generic] (local build)
Copyright (C) 2002-23, Bruce Allen, Christian Franke, www.smartmontools.org

=== START OF INFORMATION SECTION ===
Device Model:     QEMU HARDDISK
Serial Number:    QM00001
Firmware Version: 2.5+
User Capacity:    8,589,934,592 bytes [8.58 GB]
Sector Size:      512 bytes logical/physical
TRIM Command:     Available, deterministic
Device is:        Not in smartctl database 7.3/5528
ATA Version is:   ATA/ATAPI-7, ATA/ATAPI-5 published, ANSI NCITS 340-2000
Local Time is:    Tue Mar  4 05:45:56 2025 UTC
SMART support is: Available - device has SMART capability.
SMART support is: Enabled
</code></pre><p>If we wanted to match this disk by wild-carding the model name, we would use the following.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">storage</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">layout</span>:
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">name</span>: <span style="color:#ae81ff">lvm</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">sizing-policy</span>: <span style="color:#ae81ff">all</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">match</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">model</span>: <span style="color:#ae81ff">QEMU*</span>
</span></span></code></pre></div><p>Alternatively if our on-premise hardware instance had a 1GB SSD for the OS and a second 12GB spinning disk for data storage, we could
use a match with size <code>size: smallest</code> to install the OS on the 1GB disk.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">storage</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">layout</span>:
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">name</span>: <span style="color:#ae81ff">lvm</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">sizing-policy</span>: <span style="color:#ae81ff">all</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">match</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">size</span>: <span style="color:#ae81ff">smallest</span>
</span></span></code></pre></div><h3 id="commands">Commands</h3>
<p>Running arbitrary commands is possible when autoinstall runs.  Commands are specified as a list and run under &ldquo;sh -c&rdquo;.
Its  possible to specify if commands should run early in the autoinstall process, late, or when an error occurs.</p>
<p>For example we want to hit a web endpoint when the installer has completed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">late-commands</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">curl -H &#39;Content-Type</span>: <span style="color:#ae81ff">application/json&#39; --data &#39;{&#34;host&#34;: &#34;&#39;$HOSTNAME&#39;&#34;}&#39; http://myapi.example.com/success</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">echo &#34;Install Success&#34;  &gt; /var/log/my.log</span>
</span></span></code></pre></div><p>To run a command before the autoinstall process runs, like downloading internal x509 certificates:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">early-commands</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">mkdir /etc/ssl/mycerts</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">wget -O /etc/ssl/mycerts/internal.pem &#34;http://x509api.example.com/certs/$HOSTNAME&#34;</span>
</span></span></code></pre></div><p>Or reporting an error when autoinstall fails</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">error-commands</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">echo &#34;Install failed&#34; &gt; /var/log/my.log</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">curl -H &#39;Content-Type</span>: <span style="color:#ae81ff">application/json&#39; --data &#39;{&#34;host&#34;: &#34;&#39;$HOSTNAME&#39;&#34;}&#39; http://myapi.example.com/failures</span>
</span></span></code></pre></div><h3 id="cloud-init">cloud-init</h3>
<p>It&rsquo;s possible to invoke cloud-init from autoinstall, allowing for additional functionality. This is done by placing
the cloud-init entries under a user-data key.  Here&rsquo;s a cloud-init example that installs a few packages.</p>
<p>cloud-init and
autoinstall sometimes perform similar tasks. When configuring a storage device with cloud-init, I found it was
better to use autoinstall as the cloud-init changes were overwritten.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">user-data</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">package_update</span>: <span style="color:#66d9ef">true</span>    <span style="color:#75715e"># update the list of available packages</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">package_upgrade</span>: <span style="color:#66d9ef">true</span>   <span style="color:#75715e"># upgrade currently installed packages.</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">packages</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">curl</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">ca-certificates</span>
</span></span></code></pre></div><h3 id="other">Other</h3>
<p>It&rsquo;s possible to configure a local proxy for downloading software packages.  Running apt-cacher-ng as a package
proxy inside a docker container on my laptop helps when I&rsquo;m on a high latency Internet connection.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">proxy</span>: <span style="color:#ae81ff">http://10.0.2.2:3142</span>
</span></span></code></pre></div><h2 id="provision-a-physical-host">Provision a physical host</h2>
<p>A complete autoinstall user-data file can be downloaded from <a href="./assets/user-data">here</a>.  It contains all the examples listed in this post.</p>
<p>Provisioning a physical host is very similar to using QEMU. The only change is when starting the python
webserver.  Instead of python binding to 127.0.0.1, have it bind to all interfaces so configs can be downloaded
by remote hosts.</p>
<pre tabindex="0"><code class="language-code" data-lang="code">python3 -m http.server -d $PWD 8080
</code></pre><p>A USB thumb drive is needed to make the Ubuntu ISO available to the physical host; and a monitor &amp; keyboard are needed
to modify the GRUB menu when the on-premise hosts boots. When modifying the GRUB menu,
instead of using http://10.0.2.2 in the nocloud URL, specify the hostname of the host running the python webserver.  In my scenario, the hostname would
resolve to my personal laptop.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>By leveraging autoinstall, it&rsquo;s possible to reliably reproduce system setups, whether for virtual machines or bare-metal hosts.
In this post, autoinstall was explored as a method to streamline unattended provisioning for Ubuntu instances.  Using a QEMU-based test environment,
it was possible to quickly iterate on autoinstall configurations by modifying the GRUB menu to pull configuration files over HTTP.  The process demonstrated
how to format storage devices, set up networking, and run shell commands during installation.</p>
<p>Next steps?  If looking to extend this setup, consider integrating additional automation, such as PXE boot for network-based installs or using cloud-init to
interact with configuration management systems like Puppet or Chef.  If you have insights from your own experiences, feel free to share them
on <a href="https://bsky.app/profile/af9.us">Bluesky</a>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Getting started with cloud-init for unattended Linux deployments</title>
      <link>https://amf3.github.io/articles/cloudinit/intro/</link>
      <pubDate>Fri, 21 Feb 2025 23:06:35 -0800</pubDate>
      <guid>https://amf3.github.io/articles/cloudinit/intro/</guid>
      <description>An intro to using cloud-init for customizing both on-premise and cloud virtual machines</description>
      <content:encoded><![CDATA[<p>Cloud compute companies like GCP, AWS, or Azure offer a management API for allocating resources. In the on-premise space,
services such as Docker or Incus provide APIs for managing containers or virtual machines (VMs). But what about installing
the operating system (OS) on bare-metal hosts? What API exists for this task? This is where
<a href="https://github.com/canonical/cloud-init">cloud-init</a> enters the picture, providing the ability to provision VMs or
bare-metal hardware.</p>
<p>cloud-init is a useful tool that doesn&rsquo;t rely on network services like PXE as a dependency.  Its simplicity saves time by
removing the need to navigate OS installation menus, while ensuring user accounts and installed software packages are consistent
across hosts. So why should one bother using cloud-init if they are managing a single host at home? In the event
the OS needs to be reinstalled due to failure, cloud-init allows one to quickly restore the system to a known state.</p>
<p>This example will use cloud-init to configure a Personal Package Archive (PPA), install Docker, and create a user account inside a Ubuntu VM.</p>
<h2 id="prerequisite">Prerequisite</h2>
<p>I find that using cloud-init with Multipass is a easy way to get started.  Multipass is a virtual machine manager that
works with Linux, MacOS (arm &amp; intel), and Windows.  When launching a new VM, Multipass is capable of initializing the VM with cloud-init.
If Multipass isn&rsquo;t already installed, this link will provide instructions for installing
<a href="https://canonical.com/multipass/install">Multipass</a>.  For this cloud-init introduction, I&rsquo;m using Multipass on a M2 Macbook running MacOS Sequoia.</p>
<h2 id="cloud-init">cloud-init</h2>
<p>Like many infrastructure tools, the input data for cloud-init is a YAML file.  For specifics of this schema, consult the official cloud-init
<a href="https://cloudinit.readthedocs.io/en/latest/index.html">documentation</a>.  There one will find that cloud-init input file
will need to be <a href="https://cloudinit.readthedocs.io/en/latest/tutorial/qemu.html#define-the-configuration-data-files">prefixed</a> with <code>#cloud-config</code>.</p>
<h3 id="package-management">Package Management</h3>
<p>Lets get started with package management for our Multipass instance.  This section will show how to add an external PPA (software repository) to
the VM with cloud-init to provide additional software packages and define a list of software packages to be installed on the VM.</p>
<h4 id="add-external-ppa">Add External PPA</h4>
<p>Add the 3rd-party <a href="https://cloudinit.readthedocs.io/en/latest/reference/modules.html#apt-configure">PPA</a> provided by Docker, Inc.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># Add Docker&#39;s PPA for Ubuntu</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">apt</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">sources</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">docker.list</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># This snippet comes from https://stackoverflow.com/a/62540068</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">source</span>: <span style="color:#ae81ff">deb [arch=arm64] https://download.docker.com/linux/ubuntu $RELEASE stable</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># Key ID can be found with “gpg --show-keys &lt;(curl -s https://download.docker.com/linux/ubuntu/gpg)”</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">keyid</span>: <span style="color:#ae81ff">9DC858229FC7DD38854AE2D88D81803C0EBFCD88 </span>
</span></span></code></pre></div><p>Should the GPG key ID for the Docker PPA change, I have left a comment above on how to find that value.<br>
This is how the GPG output appears in 2025.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ gpg --show-keys &lt;<span style="color:#f92672">(</span>curl -s https://download.docker.com/linux/ubuntu/gpg<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>pub   rsa4096 2017-02-22 <span style="color:#f92672">[</span>SCEA<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>      9DC858229FC7DD38854AE2D88D81803C0EBFCD88
</span></span><span style="display:flex;"><span>uid                      Docker Release <span style="color:#f92672">(</span>CE deb<span style="color:#f92672">)</span> &lt;docker@docker.com&gt;
</span></span><span style="display:flex;"><span>sub   rsa4096 2017-02-22 <span style="color:#f92672">[</span>S<span style="color:#f92672">]</span>
</span></span></code></pre></div><h4 id="define-package-list">Define Package List</h4>
<p>Specify a list of <a href="https://cloudinit.readthedocs.io/en/latest/reference/modules.html#package-update-upgrade-install">packages</a> to install.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># Update the list of packages available online</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">package_update</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Upgrade all installed packages</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">package_upgrade</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Install docker &amp; other utilities</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">packages</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">apt-transport-https</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">ca-certificates</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">curl</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">gnupg-agent</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">software-properties-common</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">docker-ce</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">docker-ce-cli</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">containerd.io</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">docker-buildx-plugin</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">docker-compose-plugin</span>
</span></span></code></pre></div><h3 id="user-management">User Management</h3>
<p>Here a new <a href="https://cloudinit.readthedocs.io/en/latest/reference/yaml_examples/user_groups.html">user</a> account is created and added
to the docker group with cloud-init.  Its likely our user will require both a password &amp; ssh key for remote access.  A public ssh key and a
password hash is needed for cloud-init input.</p>
<h4 id="secrets-generating-a-password-hash">Secrets: Generating a Password Hash</h4>
<p>To create a password hash, use the <code>mkpasswd</code> command from Ubuntu&rsquo;s whois package.  This example will
hash the weak password of &ldquo;abc123&rdquo; with the sha512 algorithm.  A password better than &ldquo;abc123&rdquo; should be used if following these examples.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ mkpasswd -m sha-512 <span style="color:#e6db74">&#34;abc123&#34;</span>
</span></span><span style="display:flex;"><span>$6$EkwQ38oDCPnJDuui$QKw3IISzY3emHXgJ/QHeEH8xyzGOKB3N6.bU/wAkwf4KDRsreB2iApa/EHULbunx6v9o9Q8foq4K.d8WtHukU/
</span></span></code></pre></div><p>As mkpasswd is specific to Linux and doesn&rsquo;t work with MacOS, one can alternatively use <code>openssl</code> to create a password hash.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ echo abc123 |  openssl passwd -6 -stdin  
</span></span><span style="display:flex;"><span>$6$tdPON3RwkVViXg41$4O9euMZeGFJQXgJ3bvP3YtVcCw9BwIMHLLkix1s/R7woSuAAFvWWtrqqQ.33ESzgcUi9/HdEwelqB9jJUIrpU0
</span></span></code></pre></div><h4 id="secrets-generating-a-ssh-public-private-key-pair">Secrets: Generating a SSH public private key pair</h4>
<p>To create a SSH key pair, use ssh-keygen: <code>ssh-keygen -t ed25519 -f ./docker_vm_key -C &quot;app@docker_vm&quot; -P abc123</code>.  This will create a public &amp; private
ssh key in the current directory, with the easily guessable passphrase of <code>abc123</code>.  Once again, use a better passphrase if following these examples.</p>
<h4 id="defining-the-user-account">Defining the User Account</h4>
<p>This defines an application account named &ldquo;app&rdquo;.  The <code>ssh_authorized_keys</code> value comes from the contents of docker_vm_key.pub.<br>
As a convenience, the <a href="./assets/docker_vm_key.pub">public</a> and <a href="./assets/docker_vm_key">private</a> ssh keys from this example are provided.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># create the docker group</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">groups</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">docker</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">users</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">app</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">groups</span>: [<span style="color:#ae81ff">docker, admin, users]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">gecos</span>: <span style="color:#ae81ff">Application User</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">shell</span>: <span style="color:#ae81ff">/bin/bash</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">lock_passwd</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">passwd</span>: <span style="color:#ae81ff">$6$tdPON3RwkVViXg41$4O9euMZeGFJQXgJ3bvP3YtVcCw9BwIMHLLkix1s/R7woSuAAFvWWtrqqQ.33ESzgcUi9/HdEwelqB9jJUIrpU0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">ssh_authorized_keys</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIHsPNGa1NJLd4edDLRI033Sw33Nkl6qO+52qNAhY556C app@docker_vm</span>
</span></span></code></pre></div><h3 id="putting-it-all-together">Putting it all together</h3>
<p>I&rsquo;ve combined the YAML snippets into a single file named docker-install.yaml which can be downloaded <a href="./assets/docker-install.yaml">here</a>.<br>
Run the following to see cloud-init in action. This will create a virtual machine with 2 virtual CPU cores, 2 GB of ram,
with a 4GB virtual disk using the LTS release of Ubuntu.  Depending on your Internet speed, this may take a few minutes as
you&rsquo;ll be downloading packages from the Internet.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ multipass launch -n docker-demo --cloud-init docker-install.yaml -c <span style="color:#ae81ff">2</span> -m 2G -d 4G lts
</span></span></code></pre></div><p>To find the new VM and access it over SSH with the private key so a docker command can be ran from a remote shell.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>% mp list                                                                                                                             
</span></span><span style="display:flex;"><span>Name                    State             IPv4             Image
</span></span><span style="display:flex;"><span>docker-demo             Running           192.168.64.32    Ubuntu 24.04 LTS        
</span></span><span style="display:flex;"><span>                                          172.17.0.1     
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% ssh -l app -i ./docker_vm_key 192.168.64.32
</span></span><span style="display:flex;"><span> The authenticity of host <span style="color:#e6db74">&#39;192.168.64.32 (192.168.64.32)&#39;</span> can<span style="color:#e6db74">&#39;t be established.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> ED25519 key fingerprint is SHA256:EUqLjr9n9CyjKY6Y8EzNQGomeEtpePMFo5BXjO8YfHY.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> This key is not known by any other names.                                 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> ...
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">app@docker-demo:~$ docker run hello-world
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Unable to find image &#39;</span>hello-world:latest<span style="color:#960050;background-color:#1e0010">&#39;</span> locally
</span></span><span style="display:flex;"><span>latest: Pulling from library/hello-world
</span></span><span style="display:flex;"><span>c9c5fd25a1bd: Pull complete 
</span></span><span style="display:flex;"><span>Digest: sha256:e0b569a5163a5e6be84e210a2587e7d447e08f87a0e90798363fa44a0464a1e8
</span></span><span style="display:flex;"><span>Status: Downloaded newer image <span style="color:#66d9ef">for</span> hello-world:latest
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Hello from Docker!
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>Several cloud-init basics have been covered in this introduction. Like adding a PPA, installing software packages, and creating a user account.<br>
While I understand that installing Docker in my example might not represent the typical workflow.  Combining cloud-init concepts with Multipass
creates a local mini-cloud on my Macbook.  I can quickly iterate through cloud-init data file changes for other platforms like AWS or on-premise hardware.</p>
<p>cloud-init is capable of much more, like formatting hard drives or managing network interfaces.  These &amp; other topics will be covered in followups
which I will announce on <a href="https://bsky.app/profile/af9.us">Bluesky</a>.  Follow me for notifications of when its made available.  Otherwise,
try out these examples and let me know what works.</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
