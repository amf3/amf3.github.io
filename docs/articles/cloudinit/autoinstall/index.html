<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Unattended Ubuntu Installs - Virtual Machines to Bare-Metal | Adam Faris</title>
<meta name="keywords" content="">
<meta name="description" content="Intro
In a previous post, I discussed using cloud-init and Multipass as a method of provisioning
virtual machines on a local computer with a cloud-like API.  Today I am going
to dive deeper with Ubuntu and how their autoinstall API can simplify on-premise host provisioning.
autoinstall
is a tool that allows for unattended installations of Ubuntu, ensuring consistency, reporducibility, and providing automation
across a fleet of hosts.  In this post I&rsquo;ll walk through an example of using autoinstall
to configure networking, local storage, and demonstrate shell command execution during provisioning.">
<meta name="author" content="">
<link rel="canonical" href="https://amf3.github.io/articles/cloudinit/autoinstall/">
<meta name="google-site-verification" content="6ZFu-1_Lir3DsFJP8sshXEJ1_SjtFUw9TIISOcaJh7E">
<meta name="msvalidate.01" content="C1E02AC59FE7ECBDB6D9EFB7D5E02B65">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://amf3.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://amf3.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://amf3.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://amf3.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://amf3.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://amf3.github.io/articles/cloudinit/autoinstall/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-MKR06D6KGD"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-MKR06D6KGD');
        }
      </script><meta property="og:url" content="https://amf3.github.io/articles/cloudinit/autoinstall/">
  <meta property="og:site_name" content="Adam Faris">
  <meta property="og:title" content="Unattended Ubuntu Installs - Virtual Machines to Bare-Metal">
  <meta property="og:description" content="Intro In a previous post, I discussed using cloud-init and Multipass as a method of provisioning virtual machines on a local computer with a cloud-like API. Today I am going to dive deeper with Ubuntu and how their autoinstall API can simplify on-premise host provisioning.
autoinstall is a tool that allows for unattended installations of Ubuntu, ensuring consistency, reporducibility, and providing automation across a fleet of hosts. In this post I’ll walk through an example of using autoinstall to configure networking, local storage, and demonstrate shell command execution during provisioning.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2025-03-03T23:07:23-08:00">
    <meta property="article:modified_time" content="2025-03-03T23:07:23-08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Unattended Ubuntu Installs - Virtual Machines to Bare-Metal">
<meta name="twitter:description" content="Intro
In a previous post, I discussed using cloud-init and Multipass as a method of provisioning
virtual machines on a local computer with a cloud-like API.  Today I am going
to dive deeper with Ubuntu and how their autoinstall API can simplify on-premise host provisioning.
autoinstall
is a tool that allows for unattended installations of Ubuntu, ensuring consistency, reporducibility, and providing automation
across a fleet of hosts.  In this post I&rsquo;ll walk through an example of using autoinstall
to configure networking, local storage, and demonstrate shell command execution during provisioning.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "articles",
      "item": "https://amf3.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Unattended Ubuntu Installs - Virtual Machines to Bare-Metal",
      "item": "https://amf3.github.io/articles/cloudinit/autoinstall/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Unattended Ubuntu Installs - Virtual Machines to Bare-Metal",
  "name": "Unattended Ubuntu Installs - Virtual Machines to Bare-Metal",
  "description": "Intro In a previous post, I discussed using cloud-init and Multipass as a method of provisioning virtual machines on a local computer with a cloud-like API. Today I am going to dive deeper with Ubuntu and how their autoinstall API can simplify on-premise host provisioning.\nautoinstall is a tool that allows for unattended installations of Ubuntu, ensuring consistency, reporducibility, and providing automation across a fleet of hosts. In this post I\u0026rsquo;ll walk through an example of using autoinstall to configure networking, local storage, and demonstrate shell command execution during provisioning.\n",
  "keywords": [
    
  ],
  "articleBody": "Intro In a previous post, I discussed using cloud-init and Multipass as a method of provisioning virtual machines on a local computer with a cloud-like API. Today I am going to dive deeper with Ubuntu and how their autoinstall API can simplify on-premise host provisioning.\nautoinstall is a tool that allows for unattended installations of Ubuntu, ensuring consistency, reporducibility, and providing automation across a fleet of hosts. In this post I’ll walk through an example of using autoinstall to configure networking, local storage, and demonstrate shell command execution during provisioning.\nPrerequisite Because the final target is a bare-metal instance, I find it quicker to iterate \u0026 test autoinstall changes with QEMU on my macOS M2 laptop. QEMU is a hardware emulator which runs on Linux, macOS, \u0026 Windows, allowing the emulation of different CPUs, network cards, or storage devices. Instructions to install QEMU can be found online. For macOS, this can be as simple as running brew install qemu.\nNext we need the Ubuntu install media which can be downloaded here.\nQEMU overview Let’s get started by creating a virtual disk drive for installing Ubuntu. This can be done with qemu-img create -f qcow2 virtual_disk.img 6G which creates a 6GB virtual disk named virtual_disk.img in the current directory.\nIn the example below, the -boot once=d option instructes QEMU to boot from the virtual CD-ROM on first startup. After which QEMU will boot from the virtual disk. The other options initialize a 4 core CPU with 4GB of memory. The -net user,hostfwd string will port forward from localhost on the host system to port 22 on the virtual machine. If additional port forwarding is needed, like testing https traffic on port 443 of the VM, multiple hostfwd options seperated by commas can used. Be sure to adjust the filename and path to the Ubuntu ISO as needed.\nqemu-system-x86_64 -hda virtual_disk.img -boot once=d -cdrom ./ubuntu-24.10-live-server-amd64.iso -m 4096 -smp cpus=4 -net nic,model=virtio -net user,hostfwd=tcp:127.0.0.1:2222-:22 Autoinstall Autoinstall is included as part of the Ubuntu boot ISO and works with other provisioning tools from Canonical like Subiquity, Curtin, or cloud-init. When reading Autoinstall documentation, it’s useful to know which tool is being used during each install stage as often those options are passed to the underlying provisioning tool.\nLike Kickstart for RHEL, Autoinstall is Ubuntu’s answer to unattended installations, and uses YAML files for data input. Autoinstall uses default locations for finding the YAML files and locations can also be specified in the GRUB menu when the instance boots. Locations are specified as either a filepath or a URL. I’ll be using a URL for the file locations.\nLets create the empty YAML files and use python to create a simple webserver to serve the files. In another terminal type the following as the webserver runs in the foreground. Use cntl-c to terminate the python webserver when it’s no longer needed.\ntouch user-data meta-data network-config vendor-data python3 -m http.server -b 127.0.0.1 -d $PWD 8080 Next start the virtual machine.\nqemu-system-x86_64 -hda virtual_disk.img -boot once=d -cdrom ./ubuntu-24.10-live-server-amd64.iso -m 4096 -smp cpus=4 -net nic,model=virtio -net user,hostfwd=tcp:127.0.0.1:2222-:22 This will open a QEMU console window where we’ll interact with the GRUB menu to specify the YAML file locations. Change focus to the console window, highlight “Try or Install Ubuntu Server” and hit the \"e\" key to edit the grub menu.\nOn the line starting with “linux /casper/vmlinuz” add: autoinstall ds=nocloud\\;s=http://10.0.2.2:8080/ before the three dashes. The grub menu should look something like this when the edits are complete.\nlinux /casper/vmlinuz autoinstall ds=nocloud\\;s=http://10.0.2.2:8080/ --- initrd /casper/initrd Exit grub and boot by following the on-screen instructions to hit F10 or cntl-x. Watch the terminal running the python webserver and requests for the autoinstall YAML files should be seen. As they are empty config files, an interactive menu-driven session will present itself in the QEMU console window. To cancel the install, close the QEMU console window.\nThe GRUB modification tells autoinstall to use the nocloud plugin from cloud-init to download its configuration at the specified URL. QEMU assigns the special IP address of 10.0.2.2 to the host system when using -net user. This allows the VM to reach services running on the host such as our local Python HTTP server and why autoinstall is able to download its configurations over HTTP.\nThe YAML block should be added to the user-data file that was created earlier. The other files will remain empty. The minimal config example assigns a hostname of my-qemu-vm, creates an admin account named ubuntu, and assigns the ubuntu user the password of abc123.\nIt’s possible to generate a different secure password hash with openssl, as shown in this example: echo abc123 | openssl passwd -6 -stdin. Restart the QEMU VM so it boots from the virtual CD-ROM and modify the GRUB menu so it loads the new config when the VM boots.\n#cloud-config autoinstall: version: 1 identity: hostname: my-qemu-vm username: ubuntu password: $6$xK2amorOU9tK4jt4$zLA1RZUpo4CzyDBzPDHCT61FLOngjWpV7Q/BH9KieLsJ/VG8r/Y88YIMLIOL.vc4ZHees40IAqORxjqa7GKti/ # password is \"abc123\" Autoinstall will take several minutes to complete and will reboot when done. In some stages autoinstall can look stuck in some stages. Remember that Linux virtual consoles are available to inspect running processes. Virtual consoles are accessible by typing alt + left/right arrow key or using alt + F2 or alt + F3. (Use the option key for alt when using a Mac keyboard.) Eventually the VM will reboot and the login prompt should be visible if everything went as expected.\nAutoinstall has a list of defaults it uses when the option is present in the user-data file. After logging into the QEMU instance, it’s possible to view the specified values from the user-data YAML file that have been merged into the defaults.\nsudo less /var/log/installer/autoinstall-user-data Before continuing lets enable the ssh server, allow passwords for ssh login, and minimize the number of packages used during the install. Other options like locale or the keyboard setup can be found in the autoinstall-user-data file and added ot the example below. Restarting the QEMU VM and modifying the GRUB menu to reinstall the host OS is needed to apply the new changes to the YAML file. Reinstalling the OS also demonstrates the ease of initializing a system to a known state with autoinstall \u0026 cloud-init configs.\n#cloud-config autoinstall: version: 1 identity: hostname: my-qemu-vm username: ubuntu password: $6$xK2amorOU9tK4jt4$zLA1RZUpo4CzyDBzPDHCT61FLOngjWpV7Q/BH9KieLsJ/VG8r/Y88YIMLIOL.vc4ZHees40IAqORxjqa7GKti/ # password is \"abc123\" ssh: # Install SSH server and allow password logins allow-pw: true install-server: true source: # id can also be ubuntu-server id: ubuntu-server-minimal Networking Both autoinstall and cloud-init support a netplan-formatted network configuration, meaning the YAML network example will work with either installer.\nNetwork device names are different between distributions that use Systemd (Ubuntu, Fedora) vs OpenRC (Alpine). Where OpenRC will use easily found device names like “eth0”, or “eth1”, Systemd will use the PCI slot number. A Systemd example might look like “enp2s0”, where “en” means ethernet, and “p2s0” is the physical PCI slot. This value will change based on which slot a PCI card is plugged into. Luckily autoinstall lets us wildcard the device names.\nThis network example will work with either OpenRC or Systemd device names. It’s similar to what’s used by Ubuntu’s LiveCD.\nnetwork: version: 2 ethernets: my-en-devices: match: # This will match Systemd naming conventions for ethernet devices which start with \"en\" and set them to use DHCPv4 name: \"en*\" dhcp4: true my-eth-devices: match: # This will match OpenRC naming conventions like \"eth0\" name: \"eth*\" addresses: # This will specify a static network address - 10.10.10.2/24 nameservers: # We can modify the DNS search path \u0026 specify DNS name servers. search: - \"mycompany.local\" addresses: - 10.10.10.253 - 8.8.8.8 Storage Configuring storage can be complex when configuring per partition byte offsets. Luckily we can provide a storage device name and let defaults handle the details. I’ll show a basic lvm example but the other supported layouts are direct, and zfs.\nHere we specify a LVM configuration with a sizing policy to use the entire disk for the logical volume. If sizing-policy were set to scaled, free space would be left on the storage device for things like snapshots or further expansion.\nstorage: layout: name: lvm sizing-policy: all Its possible to target a specific drive to wipe and install a new OS with a match statement. There are multiple ways to select a storage device, model name, serial number, path, whether its rotational or not, or even big or little in size. These values can be found in smartctl output, which comes from the smartmontools package.\nubuntu@my-qemu-vm:~$ sudo apt-get install -y smartmontools ... install stuff ... ubuntu@my-qemu-vm:~$ sudo smartctl -i /dev/sda smartctl 7.4 2023-08-01 r5530 [x86_64-linux-6.11.0-18-generic] (local build) Copyright (C) 2002-23, Bruce Allen, Christian Franke, www.smartmontools.org === START OF INFORMATION SECTION === Device Model: QEMU HARDDISK Serial Number: QM00001 Firmware Version: 2.5+ User Capacity: 8,589,934,592 bytes [8.58 GB] Sector Size: 512 bytes logical/physical TRIM Command: Available, deterministic Device is: Not in smartctl database 7.3/5528 ATA Version is: ATA/ATAPI-7, ATA/ATAPI-5 published, ANSI NCITS 340-2000 Local Time is: Tue Mar 4 05:45:56 2025 UTC SMART support is: Available - device has SMART capability. SMART support is: Enabled If we wanted to match this disk by wild-carding the model name, we would use the following.\n#cloud-config autoinstall: storage: layout: name: lvm sizing-policy: all match: model: QEMU* Alternatively if our on-premise hardware instance had a 1GB SSD for the OS and a second 12GB spinning disk for data storage, we could use a match with size size: smallest to install the OS on the 1GB disk.\n#cloud-config autoinstall: storage: layout: name: lvm sizing-policy: all match: size: smallest Commands Running arbitrary commands is possible when autoinstall runs. Commands are specified as a list and run under “sh -c”. Its possible to specify if commands should run early in the autoinstall process, late, or when an error occurs.\nFor example we want to hit a web endpoint when the installer has completed.\n#cloud-config autoinstall: late-commands: - curl -H 'Content-Type: application/json' --data '{\"host\": \"'$HOSTNAME'\"}' http://myapi.example.com/success - echo \"Install Success\" \u003e /var/log/my.log To run a command before the autoinstall process runs, like downloading internal x509 certificates:\n#cloud-config autoinstall: early-commands: - mkdir /etc/ssl/mycerts - wget -O /etc/ssl/mycerts/internal.pem \"http://x509api.example.com/certs/$HOSTNAME\" Or reporting an error when autoinstall fails\n#cloud-config autoinstall: error-commands: - echo \"Install failed\" \u003e /var/log/my.log - curl -H 'Content-Type: application/json' --data '{\"host\": \"'$HOSTNAME'\"}' http://myapi.example.com/failures cloud-init It’s possible to invoke cloud-init from autoinstall, allowing for additional functionality. This is done by placing the cloud-init entries under a user-data key. Here’s a cloud-init example that installs a few packages.\ncloud-init and autoinstall sometimes perform similar tasks. When configuring a storage device with cloud-init, I found it was better to use autoinstall as the cloud-init changes were overwritten.\n#cloud-config autoinstall: user-data: package_update: true # update the list of available packages package_upgrade: true # upgrade currently installed packages. packages: - curl - ca-certificates Other It’s possible to configure a local proxy for downloading software packages. Running apt-cacher-ng as a package proxy inside a docker container on my laptop helps when I’m on a high latency Internet connection.\n#cloud-config autoinstall: proxy: http://10.0.2.2:3142 Provision a physical host A complete autoinstall user-data file can be downloaded from here. It contains all the examples listed in this post.\nProvisioning a physical host is very similar to using QEMU. The only change is when starting the python webserver. Instead of python binding to 127.0.0.1, have it bind to all interfaces so configs can be downloaded by remote hosts.\npython3 -m http.server -d $PWD 8080 A USB thumb drive is needed to make the Ubuntu ISO available to the physical host; and a monitor \u0026 keyboard are needed to modify the GRUB menu when the on-premise hosts boots. When modifying the GRUB menu, instead of using http://10.0.2.2 in the nocloud URL, specify the hostname of the host running the python webserver. In my scenario, the hostname would resolve to my personal laptop.\nWrapping Up By leveraging autoinstall, it’s possible to reliably reproduce system setups, whether for virtual machines or bare-metal hosts. In this post, autoinstall was explored as a method to streamline unattended provisioning for Ubuntu instances. Using a QEMU-based test environment, it was possible to quickly iterate on autoinstall configurations by modifying the GRUB menu to pull configuration files over HTTP. The process demonstrated how to format storage devices, set up networking, and run shell commands during installation.\nNext steps? If looking to extend this setup, consider integrating additional automation, such as PXE boot for network-based installs or using cloud-init to interact with configuration management systems like Puppet or Chef. If you have insights from your own experiences, feel free to share them on Bluesky.\n",
  "wordCount" : "2083",
  "inLanguage": "en",
  "datePublished": "2025-03-03T23:07:23-08:00",
  "dateModified": "2025-03-03T23:07:23-08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://amf3.github.io/articles/cloudinit/autoinstall/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Adam Faris",
    "logo": {
      "@type": "ImageObject",
      "url": "https://amf3.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://amf3.github.io/" accesskey="h" title="Adam Faris (Alt + H)">Adam Faris</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://amf3.github.io/search/" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
            <li>
                <a href="https://amf3.github.io/articles/" title="articles">
                    <span>articles</span>
                </a>
            </li>
            <li>
                <a href="https://amf3.github.io/about/" title="about">
                    <span>about</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://amf3.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://amf3.github.io/articles/">articles</a></div>
    <h1 class="post-title entry-hint-parent">
      Unattended Ubuntu Installs - Virtual Machines to Bare-Metal
    </h1>
    <div class="post-meta"><span title='2025-03-03 23:07:23 -0800 PST'>March 3, 2025</span>&nbsp;·&nbsp;2083 words

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#intro" aria-label="Intro">Intro</a></li>
                <li>
                    <a href="#prerequisite" aria-label="Prerequisite">Prerequisite</a><ul>
                        
                <li>
                    <a href="#qemu-overview" aria-label="QEMU overview">QEMU overview</a></li></ul>
                </li>
                <li>
                    <a href="#autoinstall" aria-label="Autoinstall">Autoinstall</a><ul>
                        
                <li>
                    <a href="#networking" aria-label="Networking">Networking</a></li>
                <li>
                    <a href="#storage" aria-label="Storage">Storage</a></li>
                <li>
                    <a href="#commands" aria-label="Commands">Commands</a></li>
                <li>
                    <a href="#cloud-init" aria-label="cloud-init">cloud-init</a></li>
                <li>
                    <a href="#other" aria-label="Other">Other</a></li></ul>
                </li>
                <li>
                    <a href="#provision-a-physical-host" aria-label="Provision a physical host">Provision a physical host</a></li>
                <li>
                    <a href="#wrapping-up" aria-label="Wrapping Up">Wrapping Up</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="intro">Intro<a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h2>
<p>In a <a href="../../../articles/cloudinit/intro/">previous post</a>, I discussed using cloud-init and Multipass as a method of provisioning
virtual machines on a local computer with a cloud-like API.  Today I am going
to dive deeper with Ubuntu and how their autoinstall API can simplify on-premise host provisioning.</p>
<p><a href="https://canonical-subiquity.readthedocs-hosted.com/en/latest/intro-to-autoinstall.html">autoinstall</a>
is a tool that allows for unattended installations of Ubuntu, ensuring consistency, reporducibility, and providing automation
across a fleet of hosts.  In this post I&rsquo;ll walk through an example of using autoinstall
to configure networking, local storage, and demonstrate shell command execution during provisioning.</p>
<h2 id="prerequisite">Prerequisite<a hidden class="anchor" aria-hidden="true" href="#prerequisite">#</a></h2>
<p>Because the final target is a bare-metal instance, I find it quicker to iterate &amp; test autoinstall changes with
QEMU on my macOS M2 laptop.  QEMU is a hardware emulator
which runs on Linux, macOS, &amp; Windows, allowing the emulation of different CPUs, network cards, or storage devices.
Instructions to <a href="https://www.qemu.org/download/#macos">install QEMU</a> can be found online.  For macOS, this can be as simple as
running <code>brew install qemu</code>.</p>
<p>Next we need the Ubuntu install media which can be downloaded
<a href="https://ubuntu.com/download/server">here</a>.</p>
<h3 id="qemu-overview">QEMU overview<a hidden class="anchor" aria-hidden="true" href="#qemu-overview">#</a></h3>
<p>Let&rsquo;s get started by creating a virtual disk drive for installing Ubuntu.  This can be done with
<code>qemu-img create -f qcow2 virtual_disk.img 6G</code> which creates a 6GB virtual disk named
virtual_disk.img in the current directory.</p>
<p>In the example below, the <code>-boot once=d</code> option instructes QEMU to boot from the virtual CD-ROM on first startup. After which QEMU will
boot from the virtual disk. The other options initialize a 4 core CPU with 4GB of memory.  The <code>-net user,hostfwd</code> string will
port forward from localhost on the host system to port 22 on the virtual machine.  If additional port forwarding is needed, like testing
https traffic on port 443 of the VM, multiple hostfwd options seperated by commas can used.  Be sure to adjust the filename and path to the Ubuntu ISO
as needed.</p>
<pre tabindex="0"><code class="language-code" data-lang="code">qemu-system-x86_64 -hda virtual_disk.img -boot once=d  -cdrom ./ubuntu-24.10-live-server-amd64.iso -m 4096 -smp cpus=4 -net nic,model=virtio -net user,hostfwd=tcp:127.0.0.1:2222-:22
</code></pre><h2 id="autoinstall">Autoinstall<a hidden class="anchor" aria-hidden="true" href="#autoinstall">#</a></h2>
<p>Autoinstall is included as part of the Ubuntu boot ISO and works with other provisioning tools from Canonical like
<a href="https://canonical-subiquity.readthedocs-hosted.com/en/latest/">Subiquity</a>,
<a href="https://curtin.readthedocs.io/en/latest/topics/overview.html">Curtin</a>, or <a href="https://cloudinit.readthedocs.io/en/latest/">cloud-init</a>.
When reading Autoinstall documentation, it&rsquo;s useful to know which tool is being used during each install stage as often those
options are passed to the underlying provisioning tool.</p>
<p>Like Kickstart for RHEL, Autoinstall is Ubuntu&rsquo;s answer to unattended
installations, and uses YAML files for data input.  Autoinstall uses default locations for finding the YAML files and locations
can also be specified in the GRUB menu when the instance boots.  Locations are specified as either a filepath or a URL.  I&rsquo;ll be
using a URL for the file locations.</p>
<p>Lets create the empty YAML files and use python to create a simple webserver to serve the files.  In another terminal type the following as the
webserver runs in the foreground.  Use cntl-c to terminate the python webserver when it&rsquo;s no longer needed.</p>
<pre tabindex="0"><code class="language-code" data-lang="code">touch user-data meta-data network-config vendor-data
python3 -m http.server -b 127.0.0.1 -d $PWD 8080
</code></pre><p>Next start the virtual machine.</p>
<pre tabindex="0"><code class="language-code" data-lang="code">qemu-system-x86_64 -hda virtual_disk.img -boot once=d  -cdrom ./ubuntu-24.10-live-server-amd64.iso -m 4096 -smp cpus=4 -net nic,model=virtio -net user,hostfwd=tcp:127.0.0.1:2222-:22
</code></pre><p>This will open a QEMU console window where we&rsquo;ll interact with the GRUB menu to specify the YAML file locations. Change focus to
the console window, highlight &ldquo;Try or Install Ubuntu Server&rdquo; and hit the <code>&quot;e&quot;</code> key to edit the grub menu.</p>
<p>On the line starting with “linux /casper/vmlinuz” add:  <code>autoinstall ds=nocloud\;s=http://10.0.2.2:8080/</code>  before
the three dashes.  The grub menu should look something like this when the edits are complete.</p>
<pre tabindex="0"><code class="language-code" data-lang="code">linux   /casper/vmlinuz autoinstall ds=nocloud\;s=http://10.0.2.2:8080/ ---
initrd  /casper/initrd  
</code></pre><p>Exit grub and boot by following the on-screen instructions to hit F10 or cntl-x.  Watch the terminal running the python webserver and
requests for the autoinstall YAML files should be seen.  As they are empty config files, an interactive menu-driven session will present itself
in the QEMU console window.  To cancel the install, close the QEMU console window.</p>
<p>The GRUB modification tells autoinstall to use the
<a href="https://cloudinit.readthedocs.io/en/latest/reference/datasources/nocloud.html">nocloud</a> plugin from cloud-init to download
its configuration at the specified URL.  QEMU assigns the special IP address of <code>10.0.2.2</code> to the host system when using <code>-net user</code>.  This allows the
VM to reach services running on the host such as our local Python HTTP server and why autoinstall is able to download its configurations over HTTP.</p>
<p>The YAML block should be added to the user-data file that was created earlier.  The other files will remain empty.
The <a href="https://github.com/canonical/subiquity/blob/main/doc/howto/autoinstall-quickstart.rst">minimal config example</a> assigns a
hostname of my-qemu-vm, creates an admin account named ubuntu, and assigns the ubuntu user the password of abc123.<br>
It&rsquo;s possible to generate a different secure password hash with openssl, as shown in
this example: <code>echo abc123 |  openssl passwd -6 -stdin</code>.  Restart the QEMU VM so it boots from the
virtual CD-ROM and modify the GRUB menu so it loads the new config when the VM boots.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">version</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">identity</span>:
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">hostname</span>: <span style="color:#ae81ff">my-qemu-vm</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">username</span>: <span style="color:#ae81ff">ubuntu</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">password</span>: <span style="color:#ae81ff">$6$xK2amorOU9tK4jt4$zLA1RZUpo4CzyDBzPDHCT61FLOngjWpV7Q/BH9KieLsJ/VG8r/Y88YIMLIOL.vc4ZHees40IAqORxjqa7GKti/</span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e"># password is &#34;abc123&#34;</span>
</span></span></code></pre></div><p>Autoinstall will take several minutes to complete and will reboot when done.  In some stages autoinstall can look stuck in some stages.
Remember that Linux virtual consoles are available to inspect running processes.  Virtual consoles are accessible by typing alt + left/right
arrow key or using alt + F2 or alt + F3.  (Use the option key for alt when using a Mac keyboard.)  Eventually the VM will reboot and the login
prompt should be visible if everything went as expected.</p>
<p>Autoinstall has a list of defaults it uses when the option is present in the user-data file.  After logging into the QEMU instance, it&rsquo;s
possible to view the specified values from the user-data YAML file that have been merged into the defaults.</p>
<pre tabindex="0"><code class="language-code" data-lang="code">sudo less /var/log/installer/autoinstall-user-data
</code></pre><p>Before continuing lets enable the ssh server, allow passwords for ssh login, and minimize the number of packages used during
the install.  Other options like locale or the keyboard setup can be found in the autoinstall-user-data file and added ot the example below.  Restarting
the QEMU VM and modifying the GRUB menu to reinstall the host OS is needed to apply the new changes to the YAML file.  Reinstalling
the OS also demonstrates the ease of initializing a system to a known state with autoinstall &amp; cloud-init configs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">version</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">identity</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">hostname</span>: <span style="color:#ae81ff">my-qemu-vm</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">username</span>: <span style="color:#ae81ff">ubuntu</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">password</span>: <span style="color:#ae81ff">$6$xK2amorOU9tK4jt4$zLA1RZUpo4CzyDBzPDHCT61FLOngjWpV7Q/BH9KieLsJ/VG8r/Y88YIMLIOL.vc4ZHees40IAqORxjqa7GKti/</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># password is &#34;abc123&#34;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">ssh</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># Install SSH server and allow password logins</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">allow-pw</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">install-server</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">source</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># id can also be ubuntu-server </span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">id</span>: <span style="color:#ae81ff">ubuntu-server-minimal</span>
</span></span></code></pre></div><h3 id="networking">Networking<a hidden class="anchor" aria-hidden="true" href="#networking">#</a></h3>
<p>Both autoinstall and cloud-init support a netplan-formatted network configuration, meaning the YAML network example will work with
either installer.</p>
<p>Network device names are different between distributions that use Systemd (Ubuntu, Fedora) vs OpenRC (Alpine).  Where OpenRC
will use easily found device names like &ldquo;eth0&rdquo;, or &ldquo;eth1&rdquo;,
<a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.net-naming-scheme.html">Systemd</a> will use the PCI slot number.
A Systemd example might look like &ldquo;enp2s0&rdquo;, where &ldquo;en&rdquo; means ethernet, and &ldquo;p2s0&rdquo; is the
<a href="https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/">physical PCI slot</a>.
This value will change based on which slot a PCI card is plugged into.  Luckily
<a href="https://canonical-subiquity.readthedocs-hosted.com/en/latest/reference/autoinstall-reference.html#network">autoinstall</a>
lets us wildcard the device names.</p>
<p>This network example will work with either OpenRC or Systemd device names.  It&rsquo;s similar to what&rsquo;s used by
<a href="https://git.launchpad.net/livecd-rootfs/tree/live-build/ubuntu-server/includes.chroot.ubuntu-server-minimal.ubuntu-server.installer/etc/cloud/cloud.cfg#n23">Ubuntu&rsquo;s LiveCD</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">network</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">version</span>: <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ethernets</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">my-en-devices</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">match</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># This will match Systemd naming conventions for ethernet devices which start with &#34;en&#34; and set them to use DHCPv4</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">name</span>: <span style="color:#e6db74">&#34;en*&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">dhcp4</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">my-eth-devices</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">match</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># This will match OpenRC naming conventions like &#34;eth0&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">name</span>: <span style="color:#e6db74">&#34;eth*&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">addresses</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#75715e"># This will specify a static network address</span>
</span></span><span style="display:flex;"><span>          - <span style="color:#ae81ff">10.10.10.2</span><span style="color:#ae81ff">/24</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">nameservers</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#75715e"># We can modify the DNS search path &amp; specify DNS name servers.</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">search</span>:
</span></span><span style="display:flex;"><span>            - <span style="color:#e6db74">&#34;mycompany.local&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">addresses</span>:
</span></span><span style="display:flex;"><span>            - <span style="color:#ae81ff">10.10.10.253</span>
</span></span><span style="display:flex;"><span>            - <span style="color:#ae81ff">8.8.8.8</span>
</span></span></code></pre></div><h3 id="storage">Storage<a hidden class="anchor" aria-hidden="true" href="#storage">#</a></h3>
<p>Configuring
<a href="https://canonical-subiquity.readthedocs-hosted.com/en/latest/reference/autoinstall-reference.html#storage">storage</a>
can be complex when configuring per partition byte offsets. Luckily we can provide a storage device name and let defaults
handle the details.  I&rsquo;ll show a basic lvm example but the other supported layouts are direct, and zfs.</p>
<p>Here we specify a LVM configuration with a sizing policy to use the entire disk for the logical volume.  If sizing-policy
were set to <code>scaled</code>, free space would be left on the storage device for things like snapshots or further expansion.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">storage</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">layout</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">lvm</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">sizing-policy</span>: <span style="color:#ae81ff">all</span>
</span></span></code></pre></div><p>Its possible to target a specific drive to wipe and install a new OS with a
<a href="https://canonical-subiquity.readthedocs-hosted.com/en/latest/reference/autoinstall-reference.html#disk-selection-extensions">match</a>
statement.  There are multiple ways to select a storage device, model name, serial number, path, whether
its rotational or not, or even big or little in size.  These values can be found in smartctl output, which
comes from the smartmontools package.</p>
<pre tabindex="0"><code class="language-code" data-lang="code">ubuntu@my-qemu-vm:~$ sudo apt-get install -y smartmontools
... install stuff ...

ubuntu@my-qemu-vm:~$ sudo smartctl -i /dev/sda
smartctl 7.4 2023-08-01 r5530 [x86_64-linux-6.11.0-18-generic] (local build)
Copyright (C) 2002-23, Bruce Allen, Christian Franke, www.smartmontools.org

=== START OF INFORMATION SECTION ===
Device Model:     QEMU HARDDISK
Serial Number:    QM00001
Firmware Version: 2.5+
User Capacity:    8,589,934,592 bytes [8.58 GB]
Sector Size:      512 bytes logical/physical
TRIM Command:     Available, deterministic
Device is:        Not in smartctl database 7.3/5528
ATA Version is:   ATA/ATAPI-7, ATA/ATAPI-5 published, ANSI NCITS 340-2000
Local Time is:    Tue Mar  4 05:45:56 2025 UTC
SMART support is: Available - device has SMART capability.
SMART support is: Enabled
</code></pre><p>If we wanted to match this disk by wild-carding the model name, we would use the following.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">storage</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">layout</span>:
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">name</span>: <span style="color:#ae81ff">lvm</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">sizing-policy</span>: <span style="color:#ae81ff">all</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">match</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">model</span>: <span style="color:#ae81ff">QEMU*</span>
</span></span></code></pre></div><p>Alternatively if our on-premise hardware instance had a 1GB SSD for the OS and a second 12GB spinning disk for data storage, we could
use a match with size <code>size: smallest</code> to install the OS on the 1GB disk.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">storage</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">layout</span>:
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">name</span>: <span style="color:#ae81ff">lvm</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">sizing-policy</span>: <span style="color:#ae81ff">all</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">match</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">size</span>: <span style="color:#ae81ff">smallest</span>
</span></span></code></pre></div><h3 id="commands">Commands<a hidden class="anchor" aria-hidden="true" href="#commands">#</a></h3>
<p>Running arbitrary commands is possible when autoinstall runs.  Commands are specified as a list and run under &ldquo;sh -c&rdquo;.
Its  possible to specify if commands should run early in the autoinstall process, late, or when an error occurs.</p>
<p>For example we want to hit a web endpoint when the installer has completed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">late-commands</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">curl -H &#39;Content-Type</span>: <span style="color:#ae81ff">application/json&#39; --data &#39;{&#34;host&#34;: &#34;&#39;$HOSTNAME&#39;&#34;}&#39; http://myapi.example.com/success</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">echo &#34;Install Success&#34;  &gt; /var/log/my.log</span>
</span></span></code></pre></div><p>To run a command before the autoinstall process runs, like downloading internal x509 certificates:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">early-commands</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">mkdir /etc/ssl/mycerts</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">wget -O /etc/ssl/mycerts/internal.pem &#34;http://x509api.example.com/certs/$HOSTNAME&#34;</span>
</span></span></code></pre></div><p>Or reporting an error when autoinstall fails</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">error-commands</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">echo &#34;Install failed&#34; &gt; /var/log/my.log</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">curl -H &#39;Content-Type</span>: <span style="color:#ae81ff">application/json&#39; --data &#39;{&#34;host&#34;: &#34;&#39;$HOSTNAME&#39;&#34;}&#39; http://myapi.example.com/failures</span>
</span></span></code></pre></div><h3 id="cloud-init">cloud-init<a hidden class="anchor" aria-hidden="true" href="#cloud-init">#</a></h3>
<p>It&rsquo;s possible to invoke cloud-init from autoinstall, allowing for additional functionality. This is done by placing
the cloud-init entries under a user-data key.  Here&rsquo;s a cloud-init example that installs a few packages.</p>
<p>cloud-init and
autoinstall sometimes perform similar tasks. When configuring a storage device with cloud-init, I found it was
better to use autoinstall as the cloud-init changes were overwritten.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">user-data</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">package_update</span>: <span style="color:#66d9ef">true</span>    <span style="color:#75715e"># update the list of available packages</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">package_upgrade</span>: <span style="color:#66d9ef">true</span>   <span style="color:#75715e"># upgrade currently installed packages.</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">packages</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">curl</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">ca-certificates</span>
</span></span></code></pre></div><h3 id="other">Other<a hidden class="anchor" aria-hidden="true" href="#other">#</a></h3>
<p>It&rsquo;s possible to configure a local proxy for downloading software packages.  Running apt-cacher-ng as a package
proxy inside a docker container on my laptop helps when I&rsquo;m on a high latency Internet connection.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e">#cloud-config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">autoinstall</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">proxy</span>: <span style="color:#ae81ff">http://10.0.2.2:3142</span>
</span></span></code></pre></div><h2 id="provision-a-physical-host">Provision a physical host<a hidden class="anchor" aria-hidden="true" href="#provision-a-physical-host">#</a></h2>
<p>A complete autoinstall user-data file can be downloaded from <a href="./assets/user-data">here</a>.  It contains all the examples listed in this post.</p>
<p>Provisioning a physical host is very similar to using QEMU. The only change is when starting the python
webserver.  Instead of python binding to 127.0.0.1, have it bind to all interfaces so configs can be downloaded
by remote hosts.</p>
<pre tabindex="0"><code class="language-code" data-lang="code">python3 -m http.server -d $PWD 8080
</code></pre><p>A USB thumb drive is needed to make the Ubuntu ISO available to the physical host; and a monitor &amp; keyboard are needed
to modify the GRUB menu when the on-premise hosts boots. When modifying the GRUB menu,
instead of using http://10.0.2.2 in the nocloud URL, specify the hostname of the host running the python webserver.  In my scenario, the hostname would
resolve to my personal laptop.</p>
<h2 id="wrapping-up">Wrapping Up<a hidden class="anchor" aria-hidden="true" href="#wrapping-up">#</a></h2>
<p>By leveraging autoinstall, it&rsquo;s possible to reliably reproduce system setups, whether for virtual machines or bare-metal hosts.
In this post, autoinstall was explored as a method to streamline unattended provisioning for Ubuntu instances.  Using a QEMU-based test environment,
it was possible to quickly iterate on autoinstall configurations by modifying the GRUB menu to pull configuration files over HTTP.  The process demonstrated
how to format storage devices, set up networking, and run shell commands during installation.</p>
<p>Next steps?  If looking to extend this setup, consider integrating additional automation, such as PXE boot for network-based installs or using cloud-init to
interact with configuration management systems like Puppet or Chef.  If you have insights from your own experiences, feel free to share them
on <a href="https://bsky.app/profile/amf3.bsky.social">Bluesky</a>.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

<ul class="share-buttons">
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://amf3.github.io/">Adam Faris</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
