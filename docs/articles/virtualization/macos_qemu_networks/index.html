<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Virtual Router Lab on macOS with QEMU | Adam Faris</title>
<meta name="keywords" content="qemu, macos, mikrotik, routeros, alpine, virtualization, networking">
<meta name="description" content="Debugging macOS QEMU networking with unified logging and lightweight Linux VMs">
<meta name="author" content="">
<link rel="canonical" href="https://amf3.github.io/articles/virtualization/macos_qemu_networks/">
<meta name="google-site-verification" content="6ZFu-1_Lir3DsFJP8sshXEJ1_SjtFUw9TIISOcaJh7E">
<meta name="msvalidate.01" content="C1E02AC59FE7ECBDB6D9EFB7D5E02B65">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css" integrity="sha256-IhHKMWS&#43;eDACT2qtKzouUghDpk&#43;PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://amf3.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://amf3.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://amf3.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://amf3.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://amf3.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://amf3.github.io/articles/virtualization/macos_qemu_networks/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-MKR06D6KGD"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-MKR06D6KGD');
        }
      </script><meta property="og:url" content="https://amf3.github.io/articles/virtualization/macos_qemu_networks/">
  <meta property="og:site_name" content="Adam Faris">
  <meta property="og:title" content="Virtual Router Lab on macOS with QEMU">
  <meta property="og:description" content="Debugging macOS QEMU networking with unified logging and lightweight Linux VMs">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2025-05-14T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-05-14T00:00:00+00:00">
    <meta property="article:tag" content="Qemu">
    <meta property="article:tag" content="Macos">
    <meta property="article:tag" content="Mikrotik">
    <meta property="article:tag" content="Routeros">
    <meta property="article:tag" content="Alpine">
    <meta property="article:tag" content="Virtualization">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Virtual Router Lab on macOS with QEMU">
<meta name="twitter:description" content="Debugging macOS QEMU networking with unified logging and lightweight Linux VMs">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "articles",
      "item": "https://amf3.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Virtual Router Lab on macOS with QEMU",
      "item": "https://amf3.github.io/articles/virtualization/macos_qemu_networks/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Virtual Router Lab on macOS with QEMU",
  "name": "Virtual Router Lab on macOS with QEMU",
  "description": "Debugging macOS QEMU networking with unified logging and lightweight Linux VMs",
  "keywords": [
    "qemu", "macos", "mikrotik", "routeros", "alpine", "virtualization", "networking"
  ],
  "articleBody": "UTM and Multipass are great apps for virtualization on macOS.\nBut I wanted a lighter-weight approach by invoking QEMU directly. Which meant I needed to understand how QEMU‚Äôs networking options interact with the vmnet virtualization API on macOS.\nThis becomes especially important when dealing with VM-to-VM connections, network isolation, and bridging on macOS.\nIn this post, I‚Äôll walk through creating a simple QEMU-based networking lab.\nSet up RouterOS and Alpine Linux VMs using QEMU on macOS Connect VMs with Apple‚Äôs Hypervisor vmnet networking APIs Use unified logging to troubleshoot QEMU network issues on macOS Lab Setup Overview The network diagram shows the network topology used in this lab. Both VMs run on on the same macOS host and connected to virtual network interfaces using QEMU‚Äôs support for Apple‚Äôs vmnet virtualization API.\nThe RouterOS VM has two virtual network interfaces, which allows it to route traffic between the Alpine Linux VM and the physical local area network.\nQEMU Networking on macOS Let‚Äôs review the vmnet.shared and vmnet.host labels in the Network1 and Network2 boxes.\nvmnet.shared: Allows traffic from the VM to reach the Internet using a built-in network address translation (NAT) feature. This is similar to how UTM‚Äôs ‚Äúshared network‚Äù mode works.\nvmnet.host: Traffic can only reach the macOS host and other VMs on the same host-mode network. This mode does not provide Internet access.\nSince the Alpine Linux VM is only connected to the vmnet.host network, and that network cannot reach the Internet, we know the RouterOS VM must be acting as the gateway. It routes traffic between Network2 (host-only) and Network1 (shared). You can confirm this by watching interface packet counts on RouterOS.\nTriple NAT! As a fun side note, traffic from the Alpine VM to the Internet passes through three layers of NAT:\nRouterOS VM NAT: Alpine‚Äôs traffic is translated as it passes through RouterOS (ether2 ‚Üí ether1). macOS vmnet NAT: vmnet0 (shared mode) applies another layer of NAT as it exits to the host‚Äôs physical LAN. Physical Router NAT: Finally, the home router applies NAT before sending packets to the Internet. Other QEMU Network Backends To see a complete list of network backends supported by QEMU:\n% qemu-system-x86_64 -netdev help Available netdev backend types: socket stream dgram hubport tap user vde bridge vhost-user vmnet-host vmnet-shared A few notes about QEMU network backends:\nsocket and user: Built into QEMU and don‚Äôt require elevated privileges. Great for quick VMs, but they don‚Äôt behave like traditional network bridges. You can‚Äôt easily interconnect multiple VMs.\ntap: Closer to a traditional bridged network and supports full traffic pass-through. However, it requires setup outside of QEMU and isn‚Äôt available on macOS, since tap interfaces depend on kernel extensions (which Apple no longer supports).\nvmnet: The backend is macOS-native and works out of the box with Apple‚Äôs Hypervisor Framework. It lets QEMU manage the bridge interfaces directly so no extra tooling is needed. Win!\nCreating the VMs RouterOS VM RouterOS ‚ÄúCloud Hosted Router‚Äù (CHR) is a commercial product with a ‚Äúfree to use‚Äù license that limits upload speed to 1 Mbps. While a paid license is available to remove the upload limit, the restriction doesn‚Äôt prevent me from validating changes before deploying them to physical networks.\nOne can download the CHR image from MikroTik‚Äôs download page. I used the stable 7.x version and chose the Raw disk image ‚Äî which is x86 (not ARM).\nüí° In hindsight, the ARM image might be more appropriate for Apple Silicon, but the x86 image works fine.\nFirst, convert the raw image to qcow2 format. This allows snapshotting the VM, making it easy to roll back from bad config changes.\n% qemu-img convert -f raw -O qcow2 chr-7.18.2.img chr-7.18.2.qcow2 % qemu-img snapshot -c original_image chr-7.18.2.qcow2 % qemu-img info chr-7.18.2.qcow2 image: chr-7.18.2.qcow2 file format: qcow2 virtual size: 128 MiB (134217728 bytes) disk size: 44.2 MiB cluster_size: 65536 Snapshot list: ID TAG VM_SIZE DATE VM_CLOCK ICOUNT 1 original_image 0 B 2025-05-08 22:40:36 0000:00:00.000 0 Format specific information: compat: 1.1 compression type: zlib lazy refcounts: false refcount bits: 16 corrupt: false extended l2: false Child node '/file': filename: chr-7.18.2.qcow2 protocol type: file file length: 44.2 MiB (46333952 bytes) disk size: 44.2 MiB Now, start the RouterOS VM and create the two virtual networks with QEMU.\nsudo qemu-system-x86_64 -m 2048 -smp cpus=4 -serial mon:stdio \\ -device virtio-scsi-pci,id=scsi0 \\ -drive file=./chr-7.18.2.qcow2,if=none,format=qcow2,discard=unmap,id=hda \\ -device scsi-hd,drive=hda,bus=scsi0.0 \\ -device virtio-net-pci,netdev=net1 \\ -netdev vmnet-shared,id=net1,start-address=172.16.0.1,end-address=172.31.255.254,subnet-mask=255.240.0.0 \\ -device virtio-net-pci,netdev=net2 \\ -netdev vmnet-host,id=net2,start-address=192.168.2.1,end-address=192.168.2.254,subnet-mask=255.255.255.0,net-uuid=154780B0-F499-4968-9B20-E58C02FDF5FB Uses sudo to create vmnet interfaces (required on macOS). Allocates 2 GB of RAM and 4 vCPUs. Opens a serial console in the terminal (handy for copy/paste). Attaches two network devices: vmnet-shared for simulated external Internet. vmnet-host for internal traffic (private LAN). IP ranges must follow RFC 1918 allocation. Using net-uuid disables the macOS DHCP server for the vmnet-host network. Required as we want the RouterOS VM to respond with DHCP replies for vmnet-host traffic. Generate the UUID with /usr/bin/uuidgen. Once RouterOS boots, log in with username admin and press Enter for a blank password. You‚Äôll be prompted to set a new one.\nTo list interfaces:\n[admin@MikroTik] \u003e /interface print Flags: R - RUNNING Columns: NAME, TYPE, ACTUAL-MTU, MAC-ADDRESS # NAME TYPE ACTUAL-MTU MAC-ADDRESS 0 R ether1 ether 1500 52:54:00:12:34:56 1 R ether2 ether 1500 52:54:00:12:34:57 2 R lo loopback 65536 00:00:00:00:00:00 To check assigned IPs:\n[admin@MikroTik] \u003e /ip/address print Flags: D - DYNAMIC Columns: ADDRESS, NETWORK, INTERFACE # ADDRESS NETWORK INTERFACE 0 D 172.16.0.2/12 172.16.0.0 ether1 Only one IP is listed ‚Äî why? The vmnet-shared interface (ether1) has DHCP enabled by Apple‚Äôs Hypervisor framework. RouterOS sends a DHCP request and gets an IP, similar to how a home router works. Meanwhile, vmnet-host has DHCP disabled, so we must assign a static IP to ether2 on the router.\nMinimal Configuration Steps Here are the minimum configuration steps to route traffic:\nassign a static IP on ether2 create a dhcpd server enable NAT [admin@MikroTik] \u003e /ip address add address=192.168.2.1/24 interface=ether2 network=192.168.2.0 [admin@MikroTik] \u003e /ip pool add name=dhcp ranges=192.168.2.50-192.168.2.100 [admin@MikroTik] \u003e /ip dhcp-server add address-pool=dhcp interface=ether2 lease-time=1h name=defconf [admin@MikroTik] \u003e /ip dhcp-server network add address=192.168.2.0/24 comment=defconf dns-server=172.16.0.1,1.1.1.1 gateway=192.168.2.1 [admin@MikroTik] \u003e /ip firewall nat add action=masquerade chain=srcnat out-interface=ether1 ‚ö†Ô∏è The example does not set any firewall rules. Use it as a starting point only.\nTo gracefully shutdown the router\n[admin@MikroTik] \u003e /system shutdown Answer y when prompted. Or, leave the router running. It will be used again shortly.\nAlpine Linux VM An Alpine ISO needs to be downloaded and installed onto a virtual hard disk. I recommend using the user network mentioned earlier for the install as additional packages will need to be downloaded from the Internet. The standard x86_64 image can be retrieved from the Alpine Linux downloads page.\nCreate a disk image to install the OS to with the qemu-img command. The options will use the qcow2 format with a max size of 2GB.\n% qemu-img create -f qcow2 alpine_disk.qcow2 2G Next step is to start a VM that boots from the Alpine ISO and connects to the Internet with the user network. Because versions change, be sure to replace the ISO filename in the -cdrom option with the one that was downloaded.\n% qemu-system-x86_64 -m 2048 -smp cpus=4 -serial stdio \\ -boot once=d \\ -cdrom ./alpine-standard-3.21.2-x86_64.iso \\ -hda ./alpine_disk.qcow2 \\ -net nic,model=virtio -net user Once the VM has started, login as ‚Äúroot‚Äù and hit Enter for the empty password. Next run setup-alpine and follow the prompts. Here are suggested answers to some of the prompts:\nSelect dhcp for eth0. Choose chrony as the network time server. Accept the default of 1 when asked which ‚Äúapk-mirror‚Äù to use. When prompted about the install disk, select sda. Answer sys to the ‚Äúhow would you like to use it‚Äù question. When the installation script is complete, type reboot and use the new root password set during the install. With the -boot once=d option, the VM will skip the ISO and boot directly from the newly installed virtual disk.\nLog in as root and install the dig and curl commands.\n# apk add bind-tools curl ca-certificates When the package install has completed, gracefully shutdown the VM with poweroff command.\nTesting the NAT Setup Check that the RouterOS VM is still running in the other terminal. It‚Äôs acting as the NAT gateway for the Alpine VM and must be active for Internet access to work. Then connect the new Alpine Linux VM to Network2 (vmnet-host) with this QEMU command.\n% sudo qemu-system-x86_64 -m 2048 -smp cpus=4 -serial mon:stdio \\ -boot c \\ -hda alpine_disk.qcow2 \\ -device virtio-net-pci,netdev=net2 \\ -netdev vmnet-host,id=net2,start-address=192.168.2.1,end-address=192.168.2.254,subnet-mask=255.255.255.0,net-uuid=154780B0-F499-4968-9B20-E58C02FDF5FB Log into the Alpine VM and verify it can reach the Internet.\nmyvm:~$ ip addr show eth0 # Confirm the IP is in the 192.168.2.x network range ... inet 192.168.2.100/24 scope global eth0 ... myvm:~$ ip route show # Confirm the default route is 192.168.2.1 default via 192.168.2.1 dev eth0 metric 202 myvm:~$ cat /etc/resolv.conf # Confirm the DNS servers were set nameserver 172.16.0.1 nameserver 1.1.1.1 myvm:~$ ping -qc 3 1.1.1.1 # test ping to 1.1.1.1 on the Internet PING 1.1.1.1 (1.1.1.1): 56 data bytes --- 1.1.1.1 ping statistics --- 3 packets transmitted, 3 packets received, 0% packet loss ... myvm:~$ dig @172.16.0.1 -t a +short www.github.com # test vmnet name resolution works github.com. 140.82.116.4 myvm:~$ curl -I https://www.github.com # test that I can fetch a webpage HTTP/2 301 ... If all of the above checks pass, your Alpine VM is correctly NAT‚Äôd through the RouterOS VM and can reach the Internet.\nTroubleshooting \u0026 Gotchas Debugging with Unified Logging macOS logs a large volume of network-related events, and it can be tricky to isolate the relevant ones. Fortunately, the log show and log collect tools make it easier to filter and investigate.\nStart by capturing a snapshot of system logs around the time your VMs are active:\n% mkdir ./log_archive % ./start_lab # start the VMs with a shell script % sudo log collect --output ./log_archive --last 3m # capture the previous 3 minutes of log events. This captures the previous 3 minutes of logs and stores them in a binary archive. Then query the relevant subsystem:\n% log show --archive log_archive/system_logs.logarchive --predicate 'subsystem == \"com.apple.NetworkSharing\"' I found the subsystem == \"com.apple.NetworkSharing\" query provided the most useful results. Using other filters like subsystem == \"com.apple.network\" or process == \"qemu-system-x86_64\" included many unrelated events and were a little overwhelming. This screenshot shows the networks being created when the VMs are started and then torn down when the VMs are stopped.\nPacket Captures with Wireshark or tcpdump Because QEMU uses virtual network interfaces, it‚Äôs possible to monitor VM traffic directly from macOS using tools like tcpdump or Wireshark. Use the ifconfig command to identify which vmenet interfaces are active and which bridge they are mapped to.\nUsing Wireshark on the correct interface reveals detailed traffic flows. In this example capture, we see:\nICMP ping requests to the router‚Äôs external interface A DNS lookup for speedtest.net An HTTP GET request initiating the speed test Other quirks I wrote a simple C program to list the interfaces created by QEMU but ran into permission errors. It turns out that macOS protects the vmnet APIs behind System Integrity Protection (SIP). To access them, binaries must be code-signed with a full Apple Developer certificate, which I don‚Äôt have (and didn‚Äôt want to pay for). Fortunately, macOS‚Äôs unified logging system provided helpful insight.\nAnother issue I encountered was with subnet settings in the router configs. At one point, I accidentally assigned 192.168.2.1/32 instead of 192.168.2.1/24 to the host-only interface on the RouterOS VM. This broke routing for the two VMs, blocking the Alpine VM from reaching the Internet.\nAt first glance QEMU‚Äôs socket-based networking may seem like a good replacement for bridged networking. It‚Äôs built into QEMU and doesn‚Äôt require elevated privileges. So why not use it? It turns out that socket networking is intended for point-to-point communication between specific QEMU instances, like TCP client/server setups. Socket networking doesn‚Äôt support general Ethernet bridging or broadcast traffic. For a more flexible setup that allows multiple VMs to communicate freely (and with the host), you still need tap or vmnet.\nConclusion Running QEMU directly on macOS isn‚Äôt the most beginner-friendly experience, but it was a great learning opportunity. I have a better appreciation for why tools like UTM or Multipass exist as wrappers around QEMU.\nNext time I might try replacing the x86 images with arm64 images to explore the performance differences. I‚Äôm also considering writing my own QEMU wrapper, partly for fun and partly for continuious integration purposes.\nIf you enjoyed this or want to follow along with future experiments, follow me on Bluesky. Thanks for reading!\n",
  "wordCount" : "2097",
  "inLanguage": "en",
  "datePublished": "2025-05-14T00:00:00Z",
  "dateModified": "2025-05-14T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://amf3.github.io/articles/virtualization/macos_qemu_networks/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Adam Faris",
    "logo": {
      "@type": "ImageObject",
      "url": "https://amf3.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://amf3.github.io/" accesskey="h" title="Adam Faris (Alt + H)">Adam Faris</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://amf3.github.io/search/" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
            <li>
                <a href="https://amf3.github.io/articles/" title="articles">
                    <span>articles</span>
                </a>
            </li>
            <li>
                <a href="https://amf3.github.io/about/" title="about">
                    <span>about</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://amf3.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://amf3.github.io/articles/">articles</a></div>
    <h1 class="post-title entry-hint-parent">
      Virtual Router Lab on macOS with QEMU
    </h1>
    <div class="post-description">
      Debugging macOS QEMU networking with unified logging and lightweight Linux VMs
    </div>
    <div class="post-meta"><span title='2025-05-14 00:00:00 +0000 UTC'>May 14, 2025</span>&nbsp;¬∑&nbsp;2097 words

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#lab-setup-overview" aria-label="Lab Setup Overview">Lab Setup Overview</a></li>
                <li>
                    <a href="#qemu-networking-on-macos" aria-label="QEMU Networking on macOS">QEMU Networking on macOS</a><ul>
                        
                <li>
                    <a href="#triple-nat" aria-label="Triple NAT!">Triple NAT!</a></li>
                <li>
                    <a href="#other-qemu-network-backends" aria-label="Other QEMU Network Backends">Other QEMU Network Backends</a></li></ul>
                </li>
                <li>
                    <a href="#creating-the-vms" aria-label="Creating the VMs">Creating the VMs</a><ul>
                        
                <li>
                    <a href="#routeros-vm" aria-label="RouterOS VM">RouterOS VM</a><ul>
                        
                <li>
                    <a href="#minimal-configuration-steps" aria-label="Minimal Configuration Steps">Minimal Configuration Steps</a></li></ul>
                </li>
                <li>
                    <a href="#alpine-linux-vm" aria-label="Alpine Linux VM">Alpine Linux VM</a></li></ul>
                </li>
                <li>
                    <a href="#testing-the-nat-setup" aria-label="Testing the NAT Setup">Testing the NAT Setup</a></li>
                <li>
                    <a href="#troubleshooting--gotchas" aria-label="Troubleshooting &amp; Gotchas">Troubleshooting &amp; Gotchas</a><ul>
                        
                <li>
                    <a href="#debugging-with-unified-logging" aria-label="Debugging with Unified Logging">Debugging with Unified Logging</a></li>
                <li>
                    <a href="#packet-captures-with-wireshark-or-tcpdump" aria-label="Packet Captures with Wireshark or tcpdump">Packet Captures with Wireshark or tcpdump</a></li>
                <li>
                    <a href="#other-quirks" aria-label="Other quirks">Other quirks</a></li></ul>
                </li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><a href="https://github.com/utmapp/UTM">UTM</a> and <a href="https://canonical.com/multipass">Multipass</a> are great apps for virtualization on macOS.<br>
But I wanted a lighter-weight approach by invoking QEMU directly.  Which meant I needed to understand how QEMU&rsquo;s networking options interact
with the <code>vmnet</code> virtualization API on macOS.</p>
<p>This becomes especially important when dealing with VM-to-VM connections, network isolation, and bridging on macOS.</p>
<p>In this post, I&rsquo;ll walk through creating a simple QEMU-based networking lab.</p>
<ul>
<li>Set up RouterOS and Alpine Linux VMs using QEMU on macOS</li>
<li>Connect VMs with Apple&rsquo;s Hypervisor <code>vmnet</code> networking APIs</li>
<li>Use unified logging to troubleshoot QEMU network issues on macOS</li>
</ul>
<h2 id="lab-setup-overview">Lab Setup Overview<a hidden class="anchor" aria-hidden="true" href="#lab-setup-overview">#</a></h2>
<p>The network diagram shows the network topology used in this lab.  Both VMs run on on the
same macOS host and connected to virtual network interfaces using QEMU&rsquo;s support for Apple&rsquo;s <strong>vmnet</strong> virtualization API.</p>
<p>The RouterOS VM has two virtual network interfaces, which allows it to route traffic between the Alpine Linux VM and the physical local area network.</p>
<p><img alt="Network Diagram" loading="lazy" src="/articles/virtualization/macos_qemu_networks/assets/Network.png#center"></p>
<h2 id="qemu-networking-on-macos">QEMU Networking on macOS<a hidden class="anchor" aria-hidden="true" href="#qemu-networking-on-macos">#</a></h2>
<p>Let&rsquo;s review the <strong>vmnet.shared</strong> and <strong>vmnet.host</strong> labels in the Network1 and Network2 boxes.</p>
<ul>
<li>
<p><a href="https://www.qemu.org/docs/master/interop/qemu-qmp-ref.html#object-QMP-net.NetdevVmnetSharedOptions"><strong>vmnet.shared</strong></a>: Allows traffic from the VM to reach the Internet using a built-in network address translation (NAT) feature. This is similar to how UTM‚Äôs &ldquo;shared network&rdquo; mode works.</p>
</li>
<li>
<p><a href="https://www.qemu.org/docs/master/interop/qemu-qmp-ref.html#object-QMP-net.NetdevVmnetHostOptions"><strong>vmnet.host</strong></a>: Traffic can only reach the macOS host and other VMs on the same host-mode network. This mode <strong>does not</strong> provide Internet access.</p>
</li>
</ul>
<p>Since the Alpine Linux VM is only connected to the <code>vmnet.host</code> network, and that network cannot reach the Internet, we know the RouterOS VM must be acting as the gateway. It routes traffic between <code>Network2</code> (host-only) and <code>Network1</code> (shared). You can confirm this by watching interface packet counts on RouterOS.</p>
<h3 id="triple-nat">Triple NAT!<a hidden class="anchor" aria-hidden="true" href="#triple-nat">#</a></h3>
<p>As a fun side note, traffic from the Alpine VM to the Internet passes through <strong>three layers of NAT</strong>:</p>
<ol>
<li><strong>RouterOS VM NAT:</strong> Alpine‚Äôs traffic is translated as it passes through RouterOS (ether2 ‚Üí ether1).</li>
<li><strong>macOS vmnet NAT:</strong> <code>vmnet0</code> (shared mode) applies another layer of NAT as it exits to the host‚Äôs physical LAN.</li>
<li><strong>Physical Router NAT:</strong> Finally, the home router applies NAT before sending packets to the Internet.</li>
</ol>
<h3 id="other-qemu-network-backends">Other QEMU Network Backends<a hidden class="anchor" aria-hidden="true" href="#other-qemu-network-backends">#</a></h3>
<p>To see a complete list of network backends supported by QEMU:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmd" data-lang="cmd"><span style="display:flex;"><span>%  qemu-system-x86_64 -netdev help  
</span></span><span style="display:flex;"><span>Available netdev backend types:
</span></span><span style="display:flex;"><span>socket
</span></span><span style="display:flex;"><span>stream
</span></span><span style="display:flex;"><span>dgram
</span></span><span style="display:flex;"><span>hubport
</span></span><span style="display:flex;"><span>tap
</span></span><span style="display:flex;"><span>user
</span></span><span style="display:flex;"><span>vde
</span></span><span style="display:flex;"><span>bridge
</span></span><span style="display:flex;"><span>vhost-user
</span></span><span style="display:flex;"><span>vmnet-host
</span></span><span style="display:flex;"><span>vmnet-shared
</span></span></code></pre></div><p>A few notes about QEMU network backends:</p>
<p><strong>socket</strong> and <strong>user</strong>: Built into QEMU and don‚Äôt require elevated privileges. Great for quick VMs, but they don‚Äôt behave like traditional network bridges. You can‚Äôt easily interconnect multiple VMs.</p>
<p><strong>tap</strong>: Closer to a traditional bridged network and supports full traffic pass-through. However, it requires setup outside of QEMU and isn‚Äôt available on macOS, since tap interfaces depend on kernel extensions (which Apple no longer supports).</p>
<p><strong>vmnet</strong>: The backend is macOS-native and works out of the box with Apple‚Äôs Hypervisor Framework.  It lets QEMU manage the bridge interfaces directly so no extra tooling is needed. Win!</p>
<h2 id="creating-the-vms">Creating the VMs<a hidden class="anchor" aria-hidden="true" href="#creating-the-vms">#</a></h2>
<h3 id="routeros-vm">RouterOS VM<a hidden class="anchor" aria-hidden="true" href="#routeros-vm">#</a></h3>
<p>RouterOS &ldquo;Cloud Hosted Router&rdquo; (CHR) is a commercial product with a &ldquo;free to use&rdquo; license that limits upload speed to 1 Mbps. While a paid license is available
to remove the upload limit, the restriction doesn&rsquo;t prevent me from validating changes before deploying them to physical networks.</p>
<p>One can download the CHR image from <a href="https://mikrotik.com/download">MikroTik‚Äôs download page</a>. I used the stable 7.x version and chose the <strong>Raw disk image</strong> ‚Äî which is x86 (not ARM).</p>
<blockquote>
<p>üí° In hindsight, the ARM image might be more appropriate for Apple Silicon, but the x86 image works fine.</p></blockquote>
<p><img alt="RouterOS download page with &lsquo;Cloud Hosted Router&rsquo; and &lsquo;Raw disk image&rsquo; highlighted" loading="lazy" src="/articles/virtualization/macos_qemu_networks/assets/routerOS-dl-screenshot.png#center"></p>
<hr>
<p>First, convert the raw image to <code>qcow2</code> format. This allows snapshotting the VM, making it easy to roll back from bad config changes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span> % qemu-img convert -f raw -O qcow2 chr-7.18.2.img chr-7.18.2.qcow2
</span></span><span style="display:flex;"><span> % qemu-img snapshot -c original_image chr-7.18.2.qcow2
</span></span><span style="display:flex;"><span> % qemu-img info chr-7.18.2.qcow2 
</span></span><span style="display:flex;"><span>image: chr-7.18.2.qcow2
</span></span><span style="display:flex;"><span>file format: qcow2
</span></span><span style="display:flex;"><span>virtual size: <span style="color:#ae81ff">128</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">134217728</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: 44.2 MiB
</span></span><span style="display:flex;"><span>cluster_size: <span style="color:#ae81ff">65536</span>
</span></span><span style="display:flex;"><span>Snapshot list:
</span></span><span style="display:flex;"><span>ID      TAG               VM_SIZE                DATE        VM_CLOCK     ICOUNT
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>       original_image        <span style="color:#ae81ff">0</span> B 2025-05-08 22:40:36  0000:00:00.000          <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>Format specific information:
</span></span><span style="display:flex;"><span>    compat: 1.1
</span></span><span style="display:flex;"><span>    compression type: zlib
</span></span><span style="display:flex;"><span>    lazy refcounts: false
</span></span><span style="display:flex;"><span>    refcount bits: <span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>    corrupt: false
</span></span><span style="display:flex;"><span>    extended l2: false
</span></span><span style="display:flex;"><span>Child node <span style="color:#e6db74">&#39;/file&#39;</span>:
</span></span><span style="display:flex;"><span>    filename: chr-7.18.2.qcow2
</span></span><span style="display:flex;"><span>    protocol type: file
</span></span><span style="display:flex;"><span>    file length: 44.2 MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">46333952</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    disk size: 44.2 MiB
</span></span></code></pre></div><p>Now, start the RouterOS VM and create the two virtual networks with QEMU.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo qemu-system-x86_64  -m <span style="color:#ae81ff">2048</span> -smp cpus<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> -serial mon:stdio  <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -device virtio-scsi-pci,id<span style="color:#f92672">=</span>scsi0 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -drive file<span style="color:#f92672">=</span>./chr-7.18.2.qcow2,if<span style="color:#f92672">=</span>none,format<span style="color:#f92672">=</span>qcow2,discard<span style="color:#f92672">=</span>unmap,id<span style="color:#f92672">=</span>hda <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -device scsi-hd,drive<span style="color:#f92672">=</span>hda,bus<span style="color:#f92672">=</span>scsi0.0 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -device virtio-net-pci,netdev<span style="color:#f92672">=</span>net1 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -netdev vmnet-shared,id<span style="color:#f92672">=</span>net1,start-address<span style="color:#f92672">=</span>172.16.0.1,end-address<span style="color:#f92672">=</span>172.31.255.254,subnet-mask<span style="color:#f92672">=</span>255.240.0.0 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -device virtio-net-pci,netdev<span style="color:#f92672">=</span>net2 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -netdev vmnet-host,id<span style="color:#f92672">=</span>net2,start-address<span style="color:#f92672">=</span>192.168.2.1,end-address<span style="color:#f92672">=</span>192.168.2.254,subnet-mask<span style="color:#f92672">=</span>255.255.255.0,net-uuid<span style="color:#f92672">=</span>154780B0-F499-4968-9B20-E58C02FDF5FB
</span></span></code></pre></div><ul>
<li>Uses sudo to create vmnet interfaces (required on macOS).</li>
<li>Allocates 2 GB of RAM and 4 vCPUs.</li>
<li>Opens a serial console in the terminal (handy for copy/paste).</li>
<li>Attaches two network devices:
<ul>
<li>vmnet-shared for simulated external Internet.</li>
<li>vmnet-host for internal traffic (private LAN).</li>
</ul>
</li>
<li>IP ranges must follow <a href="https://datatracker.ietf.org/doc/html/rfc1918">RFC 1918</a> allocation.</li>
<li>Using net-uuid disables the macOS DHCP server for the vmnet-host network.
<ul>
<li>Required as we want the RouterOS VM to respond with DHCP replies for vmnet-host traffic.</li>
<li>Generate the UUID with <strong>/usr/bin/uuidgen</strong>.</li>
</ul>
</li>
</ul>
<p>Once RouterOS boots, log in with username <strong>admin</strong> and press <strong>Enter</strong> for a blank password. You‚Äôll be prompted to set a new one.</p>
<p>To list interfaces:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">[</span>admin@MikroTik<span style="color:#f92672">]</span> &gt; /interface print 
</span></span><span style="display:flex;"><span>Flags: R - RUNNING
</span></span><span style="display:flex;"><span>Columns: NAME, TYPE, ACTUAL-MTU, MAC-ADDRESS
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   NAME    TYPE      ACTUAL-MTU  MAC-ADDRESS      </span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span> R ether1  ether           <span style="color:#ae81ff">1500</span>  52:54:00:12:34:56
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> R ether2  ether           <span style="color:#ae81ff">1500</span>  52:54:00:12:34:57
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span> R lo      loopback       <span style="color:#ae81ff">65536</span>  00:00:00:00:00:00
</span></span></code></pre></div><p>To check assigned IPs:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">[</span>admin@MikroTik<span style="color:#f92672">]</span> &gt; /ip/address print
</span></span><span style="display:flex;"><span>Flags: D - DYNAMIC
</span></span><span style="display:flex;"><span>Columns: ADDRESS, NETWORK, INTERFACE
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   ADDRESS        NETWORK     INTERFACE</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span> D 172.16.0.2/12  172.16.0.0  ether1
</span></span></code></pre></div><p>Only one IP is listed ‚Äî why?  The vmnet-shared interface (ether1) has DHCP enabled by Apple‚Äôs Hypervisor framework. RouterOS sends a DHCP
request and gets an IP, similar to how a home router works. Meanwhile, vmnet-host has DHCP disabled, so we must assign a static IP to ether2
on the router.</p>
<h4 id="minimal-configuration-steps">Minimal Configuration Steps<a hidden class="anchor" aria-hidden="true" href="#minimal-configuration-steps">#</a></h4>
<p>Here are the minimum configuration steps to route traffic:</p>
<ul>
<li>assign a static IP on ether2</li>
<li>create a dhcpd server</li>
<li>enable NAT</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">[</span>admin@MikroTik<span style="color:#f92672">]</span> &gt; /ip address add address<span style="color:#f92672">=</span>192.168.2.1/24 interface<span style="color:#f92672">=</span>ether2 network<span style="color:#f92672">=</span>192.168.2.0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>admin@MikroTik<span style="color:#f92672">]</span> &gt; /ip pool add name<span style="color:#f92672">=</span>dhcp ranges<span style="color:#f92672">=</span>192.168.2.50-192.168.2.100
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>admin@MikroTik<span style="color:#f92672">]</span> &gt; /ip dhcp-server add address-pool<span style="color:#f92672">=</span>dhcp interface<span style="color:#f92672">=</span>ether2 lease-time<span style="color:#f92672">=</span>1h name<span style="color:#f92672">=</span>defconf
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>admin@MikroTik<span style="color:#f92672">]</span> &gt; /ip dhcp-server network add address<span style="color:#f92672">=</span>192.168.2.0/24 comment<span style="color:#f92672">=</span>defconf dns-server<span style="color:#f92672">=</span>172.16.0.1,1.1.1.1 gateway<span style="color:#f92672">=</span>192.168.2.1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>admin@MikroTik<span style="color:#f92672">]</span> &gt; /ip firewall nat add action<span style="color:#f92672">=</span>masquerade chain<span style="color:#f92672">=</span>srcnat out-interface<span style="color:#f92672">=</span>ether1
</span></span></code></pre></div><blockquote>
<p>‚ö†Ô∏è The example does not set any firewall rules. Use it as a starting point only.</p></blockquote>
<p>To gracefully shutdown the router</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">[</span>admin@MikroTik<span style="color:#f92672">]</span> &gt; /system shutdown
</span></span></code></pre></div><p>Answer y when prompted. Or, leave the router running. It will be used again shortly.</p>
<h3 id="alpine-linux-vm">Alpine Linux VM<a hidden class="anchor" aria-hidden="true" href="#alpine-linux-vm">#</a></h3>
<p>An Alpine ISO needs to be downloaded and installed onto a virtual hard disk.  I recommend using the <strong>user</strong> network mentioned earlier
for the install as additional packages will need to be downloaded from the Internet.  The standard x86_64 image can be retrieved from the Alpine Linux <a href="https://alpinelinux.org/downloads/">downloads page</a>.</p>
<p>Create a disk image to install the OS to with the qemu-img command.  The options will use the qcow2 format with a max size of 2GB.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img create -f qcow2 alpine_disk.qcow2 2G
</span></span></code></pre></div><p>Next step is to start a VM that boots from the Alpine ISO and connects to the Internet with the user network.  Because versions change, be
sure to replace the ISO filename in the <strong>-cdrom</strong> option with the one that was downloaded.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-system-x86_64  -m <span style="color:#ae81ff">2048</span> -smp cpus<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> -serial stdio  <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -boot once<span style="color:#f92672">=</span>d <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -cdrom ./alpine-standard-3.21.2-x86_64.iso <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -hda ./alpine_disk.qcow2 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -net nic,model<span style="color:#f92672">=</span>virtio -net user
</span></span></code></pre></div><p>Once the VM has started, login as &ldquo;root&rdquo; and hit Enter for the empty password.  Next run <strong>setup-alpine</strong> and follow the prompts.
Here are suggested answers to some of the prompts:</p>
<ul>
<li>Select <strong>dhcp</strong> for eth0.</li>
<li>Choose <strong>chrony</strong> as the network time server.</li>
<li>Accept the default of <strong>1</strong> when asked which &ldquo;apk-mirror&rdquo; to use.</li>
<li>When prompted about the install disk, select <strong>sda</strong>.</li>
<li>Answer <strong>sys</strong> to the &ldquo;how would you like to use it&rdquo; question.</li>
</ul>
<p>When the installation script is complete, type <strong>reboot</strong> and use the new root password set during the install.  With
the <code>-boot once=d</code> option, the VM will skip the ISO and boot directly from the newly installed virtual disk.</p>
<p>Log in as root and install the dig and curl commands.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmd" data-lang="cmd"><span style="display:flex;"><span># apk add bind-tools curl ca-certificates
</span></span></code></pre></div><p>When the package install has completed, gracefully shutdown the VM with <strong>poweroff</strong> command.</p>
<h2 id="testing-the-nat-setup">Testing the NAT Setup<a hidden class="anchor" aria-hidden="true" href="#testing-the-nat-setup">#</a></h2>
<p>Check that the RouterOS VM is still running in the other terminal. It&rsquo;s acting as the NAT gateway for the Alpine VM and must be
active for Internet access to work.  Then connect the new Alpine Linux VM to Network2 (vmnet-host) with this QEMU command.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% sudo qemu-system-x86_64  -m <span style="color:#ae81ff">2048</span> -smp cpus<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> -serial mon:stdio  <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        -boot c <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        -hda alpine_disk.qcow2 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        -device virtio-net-pci,netdev<span style="color:#f92672">=</span>net2 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        -netdev vmnet-host,id<span style="color:#f92672">=</span>net2,start-address<span style="color:#f92672">=</span>192.168.2.1,end-address<span style="color:#f92672">=</span>192.168.2.254,subnet-mask<span style="color:#f92672">=</span>255.255.255.0,net-uuid<span style="color:#f92672">=</span>154780B0-F499-4968-9B20-E58C02FDF5FB
</span></span></code></pre></div><p>Log into the Alpine VM and verify it can reach the Internet.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>myvm:~$ ip addr show eth0         <span style="color:#75715e"># Confirm the IP is in the 192.168.2.x network range</span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    inet 192.168.2.100/24 scope global eth0
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>myvm:~$ ip route show             <span style="color:#75715e"># Confirm the default route is 192.168.2.1</span>
</span></span><span style="display:flex;"><span>default via 192.168.2.1 dev eth0  metric <span style="color:#ae81ff">202</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>myvm:~$ cat /etc/resolv.conf      <span style="color:#75715e"># Confirm the DNS servers were set</span>
</span></span><span style="display:flex;"><span>nameserver 172.16.0.1
</span></span><span style="display:flex;"><span>nameserver 1.1.1.1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>myvm:~$ ping -qc <span style="color:#ae81ff">3</span> 1.1.1.1        <span style="color:#75715e"># test ping to 1.1.1.1 on the Internet</span>
</span></span><span style="display:flex;"><span>PING 1.1.1.1 <span style="color:#f92672">(</span>1.1.1.1<span style="color:#f92672">)</span>: <span style="color:#ae81ff">56</span> data bytes
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>--- 1.1.1.1 ping statistics ---
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span> packets transmitted, <span style="color:#ae81ff">3</span> packets received, 0% packet loss
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>myvm:~$ dig @172.16.0.1 -t a +short www.github.com  <span style="color:#75715e"># test vmnet name resolution works </span>
</span></span><span style="display:flex;"><span>github.com.
</span></span><span style="display:flex;"><span>140.82.116.4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>myvm:~$ curl -I https://www.github.com              <span style="color:#75715e"># test that I can fetch a webpage</span>
</span></span><span style="display:flex;"><span>HTTP/2 <span style="color:#ae81ff">301</span> 
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>If all of the above checks pass, your Alpine VM is correctly NAT&rsquo;d through the RouterOS VM and can reach the Internet.</p>
<h2 id="troubleshooting--gotchas">Troubleshooting &amp; Gotchas<a hidden class="anchor" aria-hidden="true" href="#troubleshooting--gotchas">#</a></h2>
<h3 id="debugging-with-unified-logging">Debugging with Unified Logging<a hidden class="anchor" aria-hidden="true" href="#debugging-with-unified-logging">#</a></h3>
<p>macOS logs a large volume of network-related events, and it can be tricky to isolate the relevant ones. Fortunately, the <code>log show</code>
and <code>log collect</code> tools make it easier to filter and investigate.</p>
<p>Start by capturing a snapshot of system logs around the time your VMs are active:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% mkdir ./log_archive
</span></span><span style="display:flex;"><span>% ./start_lab <span style="color:#75715e"># start the VMs with a shell script</span>
</span></span><span style="display:flex;"><span>% sudo log collect --output ./log_archive --last 3m  <span style="color:#75715e"># capture the previous 3 minutes of log events.</span>
</span></span></code></pre></div><p>This captures the previous 3 minutes of logs and stores them in a binary archive. Then query the relevant subsystem:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% log show --archive log_archive/system_logs.logarchive --predicate <span style="color:#e6db74">&#39;subsystem == &#34;com.apple.NetworkSharing&#34;&#39;</span>  
</span></span></code></pre></div><p>I found the <code>subsystem == &quot;com.apple.NetworkSharing&quot;</code> query provided the most useful results.  Using other filters like <code>subsystem == &quot;com.apple.network&quot;</code>
or <code>process == &quot;qemu-system-x86_64&quot;</code> included many unrelated events and were a little overwhelming.  This screenshot shows the networks being created
when the VMs are started and then torn down when the VMs are stopped.</p>
<p><img alt="network_events" loading="lazy" src="/articles/virtualization/macos_qemu_networks/assets/network_events.png"></p>
<h3 id="packet-captures-with-wireshark-or-tcpdump">Packet Captures with Wireshark or tcpdump<a hidden class="anchor" aria-hidden="true" href="#packet-captures-with-wireshark-or-tcpdump">#</a></h3>
<p>Because QEMU uses virtual network interfaces, it&rsquo;s possible to monitor VM traffic directly from macOS using tools like tcpdump or Wireshark.  Use the
<code>ifconfig</code> command to identify which vmenet interfaces are active and which bridge they are mapped to.</p>
<p><img alt="ifconfig output" loading="lazy" src="/articles/virtualization/macos_qemu_networks/assets/ifconfig_out.png"></p>
<p>Using Wireshark on the correct interface reveals detailed traffic flows. In this example capture, we see:</p>
<ul>
<li>ICMP ping requests to the router‚Äôs external interface</li>
<li>A DNS lookup for speedtest.net</li>
<li>An HTTP GET request initiating the speed test</li>
</ul>
<p><img alt="wireshark output" loading="lazy" src="/articles/virtualization/macos_qemu_networks/assets/wireshark.png"></p>
<h3 id="other-quirks">Other quirks<a hidden class="anchor" aria-hidden="true" href="#other-quirks">#</a></h3>
<p>I wrote a simple C program to list the interfaces created by QEMU but ran into permission errors.  It turns out that macOS protects the vmnet APIs
behind System Integrity Protection (SIP). To access them, binaries must be code-signed with a full Apple Developer certificate,
which I don‚Äôt have (and didn‚Äôt want to pay for). Fortunately, macOS‚Äôs unified logging system provided helpful insight.</p>
<hr>
<p>Another issue I encountered was with subnet settings in the router configs. At one point, I accidentally assigned 192.168.2.1/32 instead
of 192.168.2.1/24 to the host-only interface on the RouterOS VM. This broke routing for the two VMs, blocking the Alpine VM from reaching the Internet.</p>
<hr>
<p>At first glance QEMU‚Äôs socket-based networking may seem like a good replacement for bridged networking. It‚Äôs built into QEMU and doesn‚Äôt require
elevated privileges. So why not use it? It turns out that socket networking is intended for point-to-point communication between specific QEMU instances, like
TCP client/server setups. Socket networking doesn‚Äôt support general Ethernet bridging or broadcast traffic. For a more flexible setup that allows multiple VMs
to communicate freely (and with the host), you still need tap or vmnet.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>Running QEMU directly on macOS isn‚Äôt the most beginner-friendly experience, but it was a great learning opportunity.  I have a better
appreciation for why tools like UTM or Multipass exist as wrappers around QEMU.</p>
<p>Next time I might try replacing the x86 images with arm64 images to explore the performance differences.  I&rsquo;m also considering writing my own QEMU wrapper,
partly for fun and partly for continuious integration purposes.</p>
<p>If you enjoyed this or want to follow along with future experiments, follow me on <a href="https://bsky.app/profile/af9.us">Bluesky</a>. Thanks for reading!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://amf3.github.io/tags/qemu/">Qemu</a></li>
      <li><a href="https://amf3.github.io/tags/macos/">Macos</a></li>
      <li><a href="https://amf3.github.io/tags/mikrotik/">Mikrotik</a></li>
      <li><a href="https://amf3.github.io/tags/routeros/">Routeros</a></li>
      <li><a href="https://amf3.github.io/tags/alpine/">Alpine</a></li>
      <li><a href="https://amf3.github.io/tags/virtualization/">Virtualization</a></li>
      <li><a href="https://amf3.github.io/tags/networking/">Networking</a></li>
    </ul>

<ul class="share-buttons">
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://amf3.github.io/">Adam Faris</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
