<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Open Container Image Format | Adam Faris</title>
<meta name="keywords" content="">
<meta name="description" content="From Local TAR file to Open Container Image">
<meta name="author" content="">
<link rel="canonical" href="https://amf3.github.io/articles/virtualization/oci_image/">
<meta name="google-site-verification" content="6ZFu-1_Lir3DsFJP8sshXEJ1_SjtFUw9TIISOcaJh7E">
<meta name="msvalidate.01" content="C1E02AC59FE7ECBDB6D9EFB7D5E02B65">
<link crossorigin="anonymous" href="/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css" integrity="sha256-NDzEgLn/yPBMy&#43;XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://amf3.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://amf3.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://amf3.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://amf3.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://amf3.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://amf3.github.io/articles/virtualization/oci_image/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-MKR06D6KGD"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-MKR06D6KGD');
        }
      </script><meta property="og:url" content="https://amf3.github.io/articles/virtualization/oci_image/">
  <meta property="og:site_name" content="Adam Faris">
  <meta property="og:title" content="Open Container Image Format">
  <meta property="og:description" content="From Local TAR file to Open Container Image">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2026-02-23T16:29:59-08:00">
    <meta property="article:modified_time" content="2026-02-23T16:29:59-08:00">
      <meta property="og:image" content="https://amf3.github.io/assets/containers.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://amf3.github.io/assets/containers.jpg">
<meta name="twitter:title" content="Open Container Image Format">
<meta name="twitter:description" content="From Local TAR file to Open Container Image">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "articles",
      "item": "https://amf3.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Open Container Image Format",
      "item": "https://amf3.github.io/articles/virtualization/oci_image/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Open Container Image Format",
  "name": "Open Container Image Format",
  "description": "From Local TAR file to Open Container Image",
  "keywords": [
    
  ],
  "articleBody": "\nForget about needing Docker’s buildx or Redhat’s buildah for this OCI container image deep dive. I will explain the OCI container image model and demonstrate building a new container image with a little JSON and a few SHA256 hash sums. You will understand that container images aren’t a file you download, but instead a graph of nodes and how the nodes are addressed after reading this article.\nThe Build Artifact A build artifact is the reproducible output created after building an application. The artifact is complete and contains all neccessary directories, compiled binaries, configs, libraries, and a directory structure. Often this is packged as a tar archive (tar) or zip file, but isn’t a requriement. The artifact contains everything needed for the application to execute in its intended environment, (arm, x86, linux, windows). There are no container specific files within the artifact, it’s just a directory tree of files.\nConvention refers to the directory tree as a root filesystem when working with container images. This is due to the directory tree being mounted at / inside the container. The root fs is not a block device filesystem like ext4.\nOCI Container Image Description A container image consists of a root filesystem and a set of JSON documents describing how the filesystem should be used. Each component of the image is stored as a content addressible blob, identified by the SHA256 hash of the blobs contents. Because identity is derived from content, any modification produces a new digest and a new image identitify instead of mutating the existing image.\nThe image contains a manifest file which ties the blobs together. The manifest references the filesystem layers and configuration file by their SHA256 digests. The configuration file defines how to run the filesystem as a container by listing what process to start, the target operating system, CPU architecture, environment variables, working directory and other execution settings.\nAdditional metadata can be associated with an image after its created, like a Software Bill of Materials. This is done by publishing a seperate artifact that references the images manifest digest. Associating metadata by reference keeps the original image unchanged.\nBecause a container image is composed of multiple content addressible blobs connected by digest references, it does not exist as a single downloadable file. Instead a container image forms a directed graph of nodes, a manifest pointing to configuration and layer blobs, and potentially additional artifacts pointing back to the manifest. Container tooling understands how to traverse this graph and retrieve the referenced content.\nElements of a OCI Container Image When stored on disk, the graph of object addressable objects is represented using a standard layout. The layout stores objects by hash and the JSON descriptors define the edges between those objects. Each object is stored under blobs//, where the filename is the cryptographic hash of its contents. If the contents change, the filename must change.\n. ├── blobs │ └── sha256 │ ├── 17eec7bbc9d79fa397ac95c7283ecd04d1fe6978516932a3db110c6206430809 │ ├── 1b44b5a3e06a9aae883e7bf25e45c100be0bb81a0e01b32de604f3ac44711634 │ └── 2771e37a12b7bcb2902456ecf3f29bf9ee11ec348e66e8eb322d9780ad7fc2df ├── index.json └── oci-layout The oci-layout file declares that the top level directory follows the OCI Image Layout specification and indicates the layout version.\n{ \"imageLayoutVersion\": \"1.0.0\" } The index.json file is the entry point of the container image and the root of the graph. The tag “latest” (“org.opencontainers.image.ref.name”: “latest”) is mapped to a specific digest (digest\": “sha256:2771e37a12b7bcb2902456ecf3f29bf9ee11ec348e66e8eb322d9780ad7fc2df”) that is marked as the manifest (“mediaType”: “application/vnd.oci.image.manifest.v1+json”).\n{ \"schemaVersion\": 2, \"manifests\": [ { \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\", \"digest\": \"sha256:2771e37a12b7bcb2902456ecf3f29bf9ee11ec348e66e8eb322d9780ad7fc2df\", \"size\": 1035, \"annotations\": { \"org.opencontainers.image.ref.name\": \"latest\" } } ] } The manifest at blobs/sha256/2771e…c2df declares the image configuration and the ordered set of filesystem layers. This example contains a single filesystem layer. In general, the layers array can contain multiple entries, which are applied in order to construct the root filesystem.\n{ \"schemaVersion\": 2, \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\", \"config\": { \"mediaType\": \"application/vnd.oci.image.config.v1+json\", \"digest\": \"sha256:1b44b5a3e06a9aae883e7bf25e45c100be0bb81a0e01b32de604f3ac44711634\", \"size\": 547 }, \"layers\": [ { \"mediaType\": \"application/vnd.oci.image.layer.v1.tar+gzip\", \"digest\": \"sha256:17eec7bbc9d79fa397ac95c7283ecd04d1fe6978516932a3db110c6206430809\", \"size\": 2380 } ], ... The trust chain is explicit with a container image. The entry point, index.json, selects a manifest by digest. The manifest selects its config and ordered filesystem layers by digest. The filename of each object under blobs/sha256 must match its contents hash.\nWhen selecting an image by tag, we are unknowingly selecting by digest. While tags are mutable references, digests are not. This is why the tag “latest” can reference a different digest then the one currently in use.\nOCI Container Image Demo We will construct an OCI container image manually to demonstrate that an image consists only of content addressed blobs and a few JSON documents. This is not a production workflow. The goal is to expose the model, not replace existing tooling. Because higher level objects reference lower level objects by digest, construction begins with the leaves of the graph. Any modification to an object would change the layer digest, which would in turn invalidate the config and manifest digests above it.\nBegin with creating a staging directory for building our conatiner image and the compiled application. The application is statically compiled and named hello. It prints a greeting defined by the GREETING environment variable, else it prints “Hello World”.\n$ mkdir -p myapp/blobs/sha256 $ tree myapp myapp └── blobs └── sha256 $ ./build/hello HELLO WORLD!!! $ GREETING=\"HELLO ADAM\" ./build/hello HELLO ADAM Next turn the “hello” application into a root filesystem blob. Currently the build artifact is in the “./build” directory which gets archived with tar. Compute the SHA256 digest on the tar archive and the archive is copied to the staging directory.\n$ tree build/ build/ └── hello $ tar --numeric-owner --owner=0 --group=0 -cf layer.tar -C build . $ sha256sum layer.tar 0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb layer.tar $ cp layer.tar myapp/blobs/sha256/0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb $ tree myapp/ myapp/ └── blobs └── sha256 └── 0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb Create a config object which tells the container runtime how to execute the filesystem. For simplicity this example uses an uncompressed tar archive. The diff_ids value matches the layer digest.\n$ cat config.json { \"architecture\": \"amd64\", \"os\": \"linux\", \"config\": { \"Env\": [], \"Entrypoint\": [\"/hello\"] }, \"rootfs\": { \"type\": \"layers\", \"diff_ids\": [ \"sha256:0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb\" ] } } $ sha256sum config.json f86f75f0d7a7dd4c951a158aca51894ab59f46b0348558a341a589bfcc0d253c config.json $ cp config.json myapp/blobs/sha256/f86f75f0d7a7dd4c951a158aca51894ab59f46b0348558a341a589bfcc0d253c The manifest binds the configuration and layer digests into a single image descriptor. The manifest file also gets hashed and stored in the staging directory.\n$ cat manifest { \"schemaVersion\": 2, \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\", \"config\": { \"mediaType\": \"application/vnd.oci.image.config.v1+json\", \"digest\": \"sha256:f86f75f0d7a7dd4c951a158aca51894ab59f46b0348558a341a589bfcc0d253c\", \"size\": 255 }, \"layers\": [ { \"mediaType\": \"application/vnd.oci.image.layer.v1.tar\", \"digest\": \"sha256:0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb\", \"size\": 1914880 } ] } $ sha256sum manifest d6fceb45932ad49b50f9a1e24b21691b60f861bf46ed9e4a47bd74b8401a2ecd manifest $ cp manifest myapp/blobs/sha256/d6fceb45932ad49b50f9a1e24b21691b60f861bf46ed9e4a47bd74b8401a2ecd Finally create the container entry point and declare the myapp directory is the top level directory of a OCI compliant image.\n$ cat myapp/index.json { \"schemaVersion\": 2, \"manifests\": [ { \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\", \"digest\": \"sha256:d6fceb45932ad49b50f9a1e24b21691b60f861bf46ed9e4a47bd74b8401a2ecd\", \"size\": 476, \"annotations\": { \"org.opencontainers.image.ref.name\": \"latest\" } } ] } $ cat myapp/oci-layout { \"imageLayoutVersion\": \"1.0.0\" } The image layout is now complete. We can import it into a runtime and execute it.\nadam@charizard:~/foo/demo$ skopeo copy oci:./myapp docker-daemon:myapp:latest Getting image source signatures Copying blob 0f11da71a27a done | Copying config f86f75f0d7 done | Writing manifest to image destination $ docker run --rm myapp:latest HELLO WORLD!!! $ docker run --rm -e GREETING=\"Hello OCI image\" myapp:latest Hello OCI image Why the Model Matters Understanding that a container image is a graph of content addressible blobs isn’t trivia. You gain several advantages when you stop seeing the image as a “magic file” and start seeing it as a verifiable manifest.\nTooling: Stop worrying about whether Docker is better than Podman. They are just different UI wrappers for the same OCI specification. Tooling becomes an implementation detail.\nDebugging: When an image is bloated or a layer is flagged by a security scanner, you don’t need specialized tools to tell you why. By inspecting the graph, you can identify exactly which object introduced the content and then inspect that specific content.\nSupply Chain Confidence: By understanding that identity is derived from content you can verify image integrity or attach metadata (like SBOMs) with confidence, knowing that objects bind to the manifest digest.\nClosing My next article will use these principals in constructing a minimal distroless image without using a base image or package manager. Reach out on BlueSky social to let me know if these topics are useful or interesting.\n",
  "wordCount" : "1362",
  "inLanguage": "en",
  "image": "https://amf3.github.io/assets/containers.jpg","datePublished": "2026-02-23T16:29:59-08:00",
  "dateModified": "2026-02-23T16:29:59-08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://amf3.github.io/articles/virtualization/oci_image/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Adam Faris",
    "logo": {
      "@type": "ImageObject",
      "url": "https://amf3.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://amf3.github.io/" accesskey="h" title="Adam Faris (Alt + H)">Adam Faris</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://amf3.github.io/search/" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
            <li>
                <a href="https://amf3.github.io/articles/" title="articles">
                    <span>articles</span>
                </a>
            </li>
            <li>
                <a href="https://amf3.github.io/about/" title="about">
                    <span>about</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://amf3.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://amf3.github.io/articles/">articles</a></div>
    <h1 class="post-title entry-hint-parent">
      Open Container Image Format
    </h1>
    <div class="post-description">
      From Local TAR file to Open Container Image
    </div>
    <div class="post-meta"><span title='2026-02-23 16:29:59 -0800 PST'>February 23, 2026</span>&nbsp;·&nbsp;<span>1362 words</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#the-build-artifact" aria-label="The Build Artifact">The Build Artifact</a></li>
                <li>
                    <a href="#oci-container-image-description" aria-label="OCI Container Image Description">OCI Container Image Description</a></li>
                <li>
                    <a href="#elements-of-a-oci-container-image" aria-label="Elements of a OCI Container Image">Elements of a OCI Container Image</a></li>
                <li>
                    <a href="#oci-container-image-demo" aria-label="OCI Container Image Demo">OCI Container Image Demo</a></li>
                <li>
                    <a href="#why-the-model-matters" aria-label="Why the Model Matters">Why the Model Matters</a></li>
                <li>
                    <a href="#closing" aria-label="Closing">Closing</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><img alt="Image of shipping containers on the pier" loading="lazy" src="/articles/virtualization/oci_image/assets/containers.jpg"></p>
<p>Forget about needing Docker&rsquo;s buildx or Redhat&rsquo;s buildah for this OCI container image deep dive. I will explain the OCI container image
model and demonstrate building a new container image with a little JSON and a few SHA256 hash sums.  You will understand that container images
aren&rsquo;t a file you download, but instead a graph of nodes and how the nodes are addressed after reading this article.</p>
<h2 id="the-build-artifact">The Build Artifact<a hidden class="anchor" aria-hidden="true" href="#the-build-artifact">#</a></h2>
<p>A build artifact is the reproducible output created after building an application. The artifact is complete and contains all neccessary
directories, compiled binaries, configs, libraries, and a directory structure.  Often this is packged as a tar archive (tar) or zip file,
but isn&rsquo;t a requriement.  The artifact contains everything needed for the application to execute in its intended environment, (arm, x86, linux,
windows).  There are no container specific files within the artifact, it&rsquo;s just a directory tree of files.</p>
<p>Convention refers to the directory tree as a <strong>root filesystem</strong> when working with container images.  This is due to the
directory tree being mounted at / inside the container.  The root fs is not a block device filesystem like ext4.</p>
<h2 id="oci-container-image-description">OCI Container Image Description<a hidden class="anchor" aria-hidden="true" href="#oci-container-image-description">#</a></h2>
<p>A container image consists of a root filesystem and a set of JSON documents describing how the filesystem should be used.
Each component of the image is stored as a content addressible blob, identified by the SHA256 hash of the blobs contents.  Because identity is
derived from content, any modification produces a new digest and a new image identitify instead of mutating the existing image.</p>
<p>The image contains a manifest file which ties the blobs together.  The manifest references the filesystem layers and configuration file by
their SHA256 digests.  The configuration file defines how to run the filesystem as a container by listing what process to start, the target
operating system, CPU architecture, environment variables, working directory and other execution settings.</p>
<p>Additional metadata can be associated with an image after its created, like a Software Bill of Materials. This is done by publishing a
seperate artifact that references the images manifest digest.  Associating metadata by reference keeps the original image unchanged.</p>
<p>Because a container image is composed of multiple content addressible blobs connected by digest references, it does not exist as a single
downloadable file.  Instead a container image forms a directed graph of nodes, a manifest pointing to configuration and layer blobs, and
potentially additional artifacts pointing back to the manifest. Container tooling understands how to traverse this graph and retrieve the
referenced content.</p>
<h2 id="elements-of-a-oci-container-image">Elements of a OCI Container Image<a hidden class="anchor" aria-hidden="true" href="#elements-of-a-oci-container-image">#</a></h2>
<p>When stored on disk, the graph of object addressable objects is represented using a
<a href="https://github.com/opencontainers/image-spec/blob/main/image-layout.md">standard layout</a>. The layout stores objects by hash and the
JSON descriptors define the edges between those objects. Each object is stored under <code>blobs/&lt;algorithm&gt;/&lt;digest&gt;</code>, where the filename is the
cryptographic hash of its contents. If the contents change, the filename must change.</p>
<pre tabindex="0"><code>.
├── blobs
│   └── sha256
│       ├── 17eec7bbc9d79fa397ac95c7283ecd04d1fe6978516932a3db110c6206430809
│       ├── 1b44b5a3e06a9aae883e7bf25e45c100be0bb81a0e01b32de604f3ac44711634
│       └── 2771e37a12b7bcb2902456ecf3f29bf9ee11ec348e66e8eb322d9780ad7fc2df
├── index.json
└── oci-layout
</code></pre><p>The <code>oci-layout</code> file declares that the top level directory follows the OCI Image Layout specification and indicates the layout version.</p>
<pre tabindex="0"><code>{
    &#34;imageLayoutVersion&#34;: &#34;1.0.0&#34;
}
</code></pre><p>The <code>index.json</code> file is the entry point of the container image and the root of the graph. The <strong>tag</strong> &ldquo;latest&rdquo;
(&ldquo;org.opencontainers.image.ref.name&rdquo;: &ldquo;latest&rdquo;) is mapped to a specific digest
(digest&quot;: &ldquo;sha256:2771e37a12b7bcb2902456ecf3f29bf9ee11ec348e66e8eb322d9780ad7fc2df&rdquo;) that is marked as the <strong>manifest</strong>
(&ldquo;mediaType&rdquo;: &ldquo;application/vnd.oci.image.manifest.v1+json&rdquo;).</p>
<pre tabindex="0"><code>{
  &#34;schemaVersion&#34;: 2,
  &#34;manifests&#34;: [
    {
      &#34;mediaType&#34;: &#34;application/vnd.oci.image.manifest.v1+json&#34;,
      &#34;digest&#34;: &#34;sha256:2771e37a12b7bcb2902456ecf3f29bf9ee11ec348e66e8eb322d9780ad7fc2df&#34;,
      &#34;size&#34;: 1035,
      &#34;annotations&#34;: {
        &#34;org.opencontainers.image.ref.name&#34;: &#34;latest&#34;
      }
    }
  ]
}
</code></pre><p>The <code>manifest</code> at blobs/sha256/2771e&hellip;c2df declares the
image configuration and the
ordered set of filesystem layers. This example contains a single filesystem layer.  In general, the
<strong>layers</strong> array can contain multiple entries, which are applied in order to construct the root
filesystem.</p>
<pre tabindex="0"><code>{
  &#34;schemaVersion&#34;: 2,
  &#34;mediaType&#34;: &#34;application/vnd.oci.image.manifest.v1+json&#34;,
  &#34;config&#34;: {
    &#34;mediaType&#34;: &#34;application/vnd.oci.image.config.v1+json&#34;,
    &#34;digest&#34;: &#34;sha256:1b44b5a3e06a9aae883e7bf25e45c100be0bb81a0e01b32de604f3ac44711634&#34;,
    &#34;size&#34;: 547
  },
  &#34;layers&#34;: [
    {
      &#34;mediaType&#34;: &#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;,
      &#34;digest&#34;: &#34;sha256:17eec7bbc9d79fa397ac95c7283ecd04d1fe6978516932a3db110c6206430809&#34;,
      &#34;size&#34;: 2380
    }
  ],
...
</code></pre><p>The trust chain is explicit with a container image. The entry point, index.json, selects a
<a href="https://github.com/opencontainers/image-spec/blob/main/media-types.md">manifest by digest</a>. The
manifest selects its config and ordered filesystem layers by digest. The filename of each object under
blobs/sha256 must match its contents hash.</p>
<p>When selecting an image by tag, we are unknowingly selecting by digest.  While tags are mutable references, digests are not. This is why the
tag &ldquo;latest&rdquo; can reference a different digest then the one currently in use.</p>
<h2 id="oci-container-image-demo">OCI Container Image Demo<a hidden class="anchor" aria-hidden="true" href="#oci-container-image-demo">#</a></h2>
<p>We will construct an OCI container image manually to demonstrate that an image consists only of content addressed blobs and a few
JSON documents.  This is not a production workflow. The goal is to expose the model, not replace existing tooling.  Because higher
level objects reference lower level objects by digest, construction begins with the leaves of the graph. Any modification
to an object would change the layer digest, which would in turn invalidate the config and manifest digests above it.</p>
<p>Begin with creating a staging directory for building our conatiner image and the compiled application.  The application is statically
compiled and named <strong>hello</strong>. It prints a greeting defined by the <a href="./assets/hello.go">GREETING</a> environment variable, else it prints &ldquo;Hello World&rdquo;.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ mkdir -p myapp/blobs/sha256
</span></span><span style="display:flex;"><span>$ tree myapp
</span></span><span style="display:flex;"><span>myapp
</span></span><span style="display:flex;"><span>└── blobs
</span></span><span style="display:flex;"><span>    └── sha256
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ ./build/hello 
</span></span><span style="display:flex;"><span>HELLO WORLD!!!
</span></span><span style="display:flex;"><span>$ GREETING<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;HELLO ADAM&#34;</span> ./build/hello 
</span></span><span style="display:flex;"><span>HELLO ADAM
</span></span></code></pre></div><p>Next turn the &ldquo;hello&rdquo; application into a root filesystem blob.  Currently the build artifact is in the &ldquo;./build&rdquo; directory which
gets archived with tar.  Compute the SHA256 digest on the tar archive and the archive is copied to the staging directory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ tree build/
</span></span><span style="display:flex;"><span>build/
</span></span><span style="display:flex;"><span>└── hello
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ tar --numeric-owner --owner<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> --group<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -cf layer.tar -C build .
</span></span><span style="display:flex;"><span>$ sha256sum layer.tar 
</span></span><span style="display:flex;"><span>0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb  layer.tar
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ cp layer.tar myapp/blobs/sha256/0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ tree myapp/
</span></span><span style="display:flex;"><span>myapp/
</span></span><span style="display:flex;"><span>└── blobs
</span></span><span style="display:flex;"><span>    └── sha256
</span></span><span style="display:flex;"><span>        └── 0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb
</span></span></code></pre></div><p>Create a config object which tells the container runtime how to execute the filesystem. For simplicity this example uses an uncompressed tar
archive. The diff_ids value matches the layer digest.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ cat config.json 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;architecture&#34;</span>: <span style="color:#e6db74">&#34;amd64&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;os&#34;</span>: <span style="color:#e6db74">&#34;linux&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;config&#34;</span>: <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Env&#34;</span>: <span style="color:#f92672">[]</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Entrypoint&#34;</span>: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/hello&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;rootfs&#34;</span>: <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;layers&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;diff_ids&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;sha256:0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ sha256sum config.json
</span></span><span style="display:flex;"><span>f86f75f0d7a7dd4c951a158aca51894ab59f46b0348558a341a589bfcc0d253c  config.json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ cp config.json myapp/blobs/sha256/f86f75f0d7a7dd4c951a158aca51894ab59f46b0348558a341a589bfcc0d253c
</span></span></code></pre></div><p>The manifest binds the configuration and layer digests into a single image descriptor. The manifest
file also gets hashed and stored in the staging directory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ cat manifest 
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schemaVersion&#34;</span>: 2,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;mediaType&#34;</span>: <span style="color:#e6db74">&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;config&#34;</span>: <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;mediaType&#34;</span>: <span style="color:#e6db74">&#34;application/vnd.oci.image.config.v1+json&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;digest&#34;</span>: <span style="color:#e6db74">&#34;sha256:f86f75f0d7a7dd4c951a158aca51894ab59f46b0348558a341a589bfcc0d253c&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;size&#34;</span>: <span style="color:#ae81ff">255</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;layers&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;mediaType&#34;</span>: <span style="color:#e6db74">&#34;application/vnd.oci.image.layer.v1.tar&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;digest&#34;</span>: <span style="color:#e6db74">&#34;sha256:0f11da71a27abfb549ba01cc400d393388116da84abb5f092572c5f2146398cb&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;size&#34;</span>: <span style="color:#ae81ff">1914880</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ sha256sum manifest
</span></span><span style="display:flex;"><span>d6fceb45932ad49b50f9a1e24b21691b60f861bf46ed9e4a47bd74b8401a2ecd  manifest
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ cp manifest myapp/blobs/sha256/d6fceb45932ad49b50f9a1e24b21691b60f861bf46ed9e4a47bd74b8401a2ecd
</span></span></code></pre></div><p>Finally create the container entry point and declare the myapp directory is the top level directory of a OCI compliant image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ cat myapp/index.json
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schemaVersion&#34;</span>: 2,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;manifests&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;mediaType&#34;</span>: <span style="color:#e6db74">&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;digest&#34;</span>: <span style="color:#e6db74">&#34;sha256:d6fceb45932ad49b50f9a1e24b21691b60f861bf46ed9e4a47bd74b8401a2ecd&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;size&#34;</span>: 476,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;annotations&#34;</span>: <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;org.opencontainers.image.ref.name&#34;</span>: <span style="color:#e6db74">&#34;latest&#34;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ cat myapp/oci-layout
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;imageLayoutVersion&#34;</span>: <span style="color:#e6db74">&#34;1.0.0&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>The image layout is now complete. We can import it into a runtime and execute it.</p>
<pre tabindex="0"><code>adam@charizard:~/foo/demo$ skopeo copy oci:./myapp docker-daemon:myapp:latest
Getting image source signatures
Copying blob 0f11da71a27a done   | 
Copying config f86f75f0d7 done   | 
Writing manifest to image destination

$ docker run --rm myapp:latest 
HELLO WORLD!!!
$ docker run --rm -e GREETING=&#34;Hello OCI image&#34; myapp:latest 
Hello OCI image
</code></pre><h2 id="why-the-model-matters">Why the Model Matters<a hidden class="anchor" aria-hidden="true" href="#why-the-model-matters">#</a></h2>
<p>Understanding that a container image is a graph of content addressible blobs isn&rsquo;t trivia.  You gain several advantages when you stop seeing the image as a &ldquo;magic file&rdquo; and start seeing it
as a verifiable manifest.</p>
<p><strong>Tooling:</strong> Stop worrying about whether Docker is better than Podman. They are just different UI wrappers for the same OCI specification. Tooling becomes an implementation detail.</p>
<p><strong>Debugging:</strong> When an image is bloated or a layer is flagged by a security scanner, you don&rsquo;t need specialized tools to tell you why.  By inspecting the graph, you can identify exactly which
object introduced the content and then inspect that specific content.</p>
<p><strong>Supply Chain Confidence:</strong> By understanding that identity is derived from content you can verify image integrity or attach metadata (like SBOMs) with
confidence, knowing that objects bind to the manifest digest.</p>
<h2 id="closing">Closing<a hidden class="anchor" aria-hidden="true" href="#closing">#</a></h2>
<p>My next article will use these principals in constructing a minimal distroless image without using a base image or package manager. Reach out on
<a href="https://bsky.app/profile/af9.us">BlueSky social</a> to let me know if these topics are useful or interesting.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

<ul class="share-buttons">
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://amf3.github.io/">Adam Faris</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
