<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Tips for working with qemu images | Adam Faris</title>
<meta name="keywords" content="">
<meta name="description" content="About QEMU images
QEMU uses files to emulate storage devices, and the features available
depend on how those files are created.  While QEMU can emulate disks from Parallels and VirtualBox, I’m going to
focus on the formats most commonly used in automation and scripting, raw and qcow2.
The default format is raw and raw offers the fewest features.  It&rsquo;s just plain storage.  The other format qcow2
supports compression, snapshots, and copy-on-write in addition to storage.">
<meta name="author" content="">
<link rel="canonical" href="https://amf3.github.io/articles/virtualization/qemuimage_tips/">
<meta name="google-site-verification" content="6ZFu-1_Lir3DsFJP8sshXEJ1_SjtFUw9TIISOcaJh7E">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://amf3.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://amf3.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://amf3.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://amf3.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://amf3.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://amf3.github.io/articles/virtualization/qemuimage_tips/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-MKR06D6KGD"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-MKR06D6KGD');
        }
      </script><meta property="og:url" content="https://amf3.github.io/articles/virtualization/qemuimage_tips/">
  <meta property="og:site_name" content="Adam Faris">
  <meta property="og:title" content="Tips for working with qemu images">
  <meta property="og:description" content="About QEMU images QEMU uses files to emulate storage devices, and the features available depend on how those files are created. While QEMU can emulate disks from Parallels and VirtualBox, I’m going to focus on the formats most commonly used in automation and scripting, raw and qcow2.
The default format is raw and raw offers the fewest features. It’s just plain storage. The other format qcow2 supports compression, snapshots, and copy-on-write in addition to storage.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2025-04-06T07:41:29-04:00">
    <meta property="article:modified_time" content="2025-04-06T07:41:29-04:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tips for working with qemu images">
<meta name="twitter:description" content="About QEMU images
QEMU uses files to emulate storage devices, and the features available
depend on how those files are created.  While QEMU can emulate disks from Parallels and VirtualBox, I’m going to
focus on the formats most commonly used in automation and scripting, raw and qcow2.
The default format is raw and raw offers the fewest features.  It&rsquo;s just plain storage.  The other format qcow2
supports compression, snapshots, and copy-on-write in addition to storage.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "articles",
      "item": "https://amf3.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Tips for working with qemu images",
      "item": "https://amf3.github.io/articles/virtualization/qemuimage_tips/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Tips for working with qemu images",
  "name": "Tips for working with qemu images",
  "description": "About QEMU images QEMU uses files to emulate storage devices, and the features available depend on how those files are created. While QEMU can emulate disks from Parallels and VirtualBox, I’m going to focus on the formats most commonly used in automation and scripting, raw and qcow2.\nThe default format is raw and raw offers the fewest features. It\u0026rsquo;s just plain storage. The other format qcow2 supports compression, snapshots, and copy-on-write in addition to storage.\n",
  "keywords": [
    
  ],
  "articleBody": "About QEMU images QEMU uses files to emulate storage devices, and the features available depend on how those files are created. While QEMU can emulate disks from Parallels and VirtualBox, I’m going to focus on the formats most commonly used in automation and scripting, raw and qcow2.\nThe default format is raw and raw offers the fewest features. It’s just plain storage. The other format qcow2 supports compression, snapshots, and copy-on-write in addition to storage.\nRaw Format Creating a raw disk with qemu-img is similar to using dd to create a block-based file. One can see this with the output of qemu-img info.\nHere I create two storage devices, one with qemu-img which defaults to the raw format and another with the dd command.\n% qemu-img create my_disk.img +1m Formatting 'my_disk.img', fmt=raw size=1048576 % dd if=/dev/zero of=my_block.file count=1 bs=1m 1+0 records in 1+0 records out Now let’s use qemu-img info to confirm there’s no difference between the two files.\n% qemu-img info my_disk.img image: my_disk.img file format: raw virtual size: 1 MiB (1048576 bytes) disk size: 1 MiB Child node '/file': filename: my_disk.img protocol type: file file length: 1 MiB (1048576 bytes) disk size: 1 MiB % qemu-img info my_block.file image: my_block.file file format: raw virtual size: 1 MiB (1048576 bytes) disk size: 1 MiB Child node '/file': filename: my_block.file protocol type: file file length: 1 MiB (1048576 bytes) disk size: 1 MiB Qcow2 Format Creating a disk in qcow2 format enables zlib compression by default.\n% qemu-img create -f qcow2 my_disk.img 1M Formatting 'my_disk.img', fmt=qcow2 cluster_size=65536 extended_l2=off compression_type=zlib size=1048576 lazy_refcounts=off refcount_bits=16 % qemu-img info my_disk.img image: my_disk.img file format: qcow2 virtual size: 1 MiB (1048576 bytes) disk size: 196 KiB cluster_size: 65536 Format specific information: compat: 1.1 compression type: zlib lazy refcounts: false refcount bits: 16 corrupt: false extended l2: false Child node '/file': filename: my_disk.img protocol type: file file length: 192 KiB (197120 bytes) disk size: 196 KiB Tip One - Resize an image file It’s possible to grow or shrink a QEMU storage device. Think of this as expanding the physical SSD itself, not the filesystem that sits on it. Important, when shrinking a image with negative values, always shrink the filesystem first using resize2fs before running qemu-img resize or risk data corruption.\n% qemu-img resize my_disk.img +1m Image resized. When inspecting the new disk image, we see the new capacity is 2MB but the file size on disk is under 200KB. This is because qcow2 supports copy-on-write and compression.\n% qemu-img info my_disk.img image: my_disk.img file format: qcow2 virtual size: 2 MiB (2097152 bytes) disk size: 196 KiB cluster_size: 65536 Format specific information: compat: 1.1 compression type: zlib lazy refcounts: false refcount bits: 16 corrupt: false extended l2: false Child node '/file': filename: my_disk.img protocol type: file file length: 192 KiB (197120 bytes) disk size: 196 KiB % ls -lh my_disk.img -rw-r--r-- 1 adam staff 192K Apr 6 10:19 my_disk.img If I were to resize a QEMU storage file formatted as raw, the file size on disk of 2MB matches the image capacity of 2MB as raw doesn’t support compression or copy-on-write.\n% qemu-img create raw_disk.img +2m Formatting 'raw_disk.img', fmt=raw size=2097152 % ls -lh raw_disk.img -rw-r--r-- 1 adam staff 2.0M Apr 6 10:22 raw_disk.img Tip Two - Snapshots Snapshots are supported with qcow2 devices. These are handy for creating a base disk image that’s shareable and later modified for other purposes. Snapshots also make a great backup point before making image changes.\nTo create a snapshot named “my_first_snapshot” inside an existing qcow2 image.\n% qemu-img snapshot -c my_first_snapshot my_disk.img To list existing snapshots\n% qemu-img snapshot -l my_disk.img Snapshot list: ID TAG VM_SIZE DATE VM_CLOCK ICOUNT 1 my_first_snapshot 0 B 2025-04-06 10:37:07 0000:00:00.000 0 To revert or “apply” a snapshot\n% qemu-img snapshot -a my_first_snapshot my_disk.img To delete a snapshot from a file\n% qemu-img snapshot -d my_first_snapshot my_disk.img Tip Three - Modify a QEMU image While many online guides suggest using the Network Block Device (NBD) kernel driver in Linux to mount and modify QEMU images, I use a different process that also works on MacOS. My preferred method is to boot a VM using QEMU and attaching the image as a data drive.\nThis example uses the extended x86_64 Alpine Linux ISO and a QEMU command that mounts the image as a data drive. The Alpine extended ISO lets you log in as root with an empty password, which makes quick edits easy.\n#/bin/sh qemu-system-x86_64 \\ -m 2G -smp cpus=4 -serial stdio \\ -boot once=d \\ -drive file=./my_disk.img,format=qcow2,media=disk,cache=unsafe \\ -drive file=./alpine-extended-3.21.2-x86_64.iso,format=raw,media=cdrom \\ -nic user,model=virtio-net-pci,hostfwd=tcp::2222-:22 Once logged in, you’ll see the QEMU file we want to modify listed as /dev/sda. The device hasn’t been formatted with a filesystem, but if one were present it could be mounted within the VM, files edited within the image, and then unmounted.\nTip Four - Transfer a QEMU image to bare-metal It’s possible to use a QEMU image with bare-metal by converting it to raw format. Use the following to convert the image from qcow2 to raw.\n% qemu-img convert -f qcow2 -O raw my_disk.img raw_disk.img % qemu-img info raw_disk.img image: raw_disk.img file format: raw virtual size: 10 MiB (10485760 bytes) disk size: 10 MiB Child node '/file': filename: raw_disk.img protocol type: file file length: 10 MiB (10485760 bytes) disk size: 10 MiB Once we have the raw image, the dd command can be used to write the data to either a USB stick or physical SSD. To avoid any destructive commands let’s pretend raw_disk2.img represents /dev/sdc, your verified USB thumb drive.\n% dd if=raw_disk.img of=raw_disk2.img bs=1m 10+0 records in 10+0 records out 10485760 bytes transferred in 0.006266 secs (1673437600 bytes/sec) Because our raw file is only 10MB in size, only 10MB will be used on the thumb drive. This is where follow up tools like LVM or resize2fs will extend the filesystem to fill the entire thumb drive. Tools used for expansion depends on how the filesystem was created.\nPutting it all together Enough with the documentation, let’s put it into practice with a real use case. Presume that after reading my cloud-init tutorials you wish to modify the Alpine Linux cloud-init image before installation.\nWe can see the downloaded file is a qcow2 image with a capacity of 200Mb from qemu-img info.\n% qemu-img info nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 image: nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 file format: qcow2 virtual size: 200 MiB (209715200 bytes) disk size: 181 MiB ... As we want to install our java app into the installer, we need to add space to the image with qemu-img resize. But first, let’s create a snapshot. That way, if we make a mistake, we won’t need to re-download the cloud-init image.\n% qemu-img snapshot -c no_modifications nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 % qemu-img resize nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 +800M Image resized. % qemu-img info nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 image: nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 file format: qcow2 virtual size: 0.977 GiB (1048576000 bytes) disk size: 197 MiB cluster_size: 65536 Snapshot list: ID TAG VM_SIZE DATE VM_CLOCK ICOUNT 1 no_modifications 0 B 2025-04-06 15:23:50 0000:00:00.000 0 Format specific information: ... I’m still using the Alpine extended ISO to boot the VM. Alpine cloud images require setup for ssh key authentication to login and an empty root password is much easier to use.\n% qemu-system-x86_64 \\ -m 2G -smp cpus=4 -serial stdio \\ -boot once=d \\ -drive file=./nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2,format=qcow2,media=disk,cache=unsafe \\ -drive file=./alpine-extended-3.21.2-x86_64.iso,format=raw,media=cdrom \\ -nic user,model=virtio-net-pci,hostfwd=tcp::2222-:22 Login as root and mount the disk device under /mnt\nlocalhost:~# mount /dev/sda /mnt localhost:~# ls /mnt bin home mnt run tmp boot lib opt sbin usr dev lost+found proc srv var etc media root sys Then make changes to the cloud image, unmount the filesystem and you’re done.\nlocalhost:~# echo \"Adam Faris was here\" \u003e /mnt/etc/motd localhost:~# cat /mnt/etc/motd Adam Faris was here localhost:~# umount /mnt localhost:~# poweroff Finally, convert our modified cloud image from qcow2 format to raw format, then use dd to write the raw image to a USB device.\n% qemu-img convert -f qcow2 -O nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 alpine_cloudinit.raw % dd if=alpine_cloudinit.raw bs=1m of=/dev/... With the modified image written to the USB device, you can now boot a physical machine from it. Thanks for sticking with me until the end. If you find this content useful, follow me on BlueSky social for future announcements.\n",
  "wordCount" : "1361",
  "inLanguage": "en",
  "datePublished": "2025-04-06T07:41:29-04:00",
  "dateModified": "2025-04-06T07:41:29-04:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://amf3.github.io/articles/virtualization/qemuimage_tips/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Adam Faris",
    "logo": {
      "@type": "ImageObject",
      "url": "https://amf3.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://amf3.github.io/" accesskey="h" title="Adam Faris (Alt + H)">Adam Faris</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://amf3.github.io/search/" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
            <li>
                <a href="https://amf3.github.io/articles/" title="articles">
                    <span>articles</span>
                </a>
            </li>
            <li>
                <a href="https://amf3.github.io/about/" title="about">
                    <span>about</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://amf3.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://amf3.github.io/articles/">articles</a></div>
    <h1 class="post-title entry-hint-parent">
      Tips for working with qemu images
    </h1>
    <div class="post-meta"><span title='2025-04-06 07:41:29 -0400 EDT'>April 6, 2025</span>&nbsp;·&nbsp;1361 words

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#about-qemu-images" aria-label="About QEMU images">About QEMU images</a><ul>
                        
                <li>
                    <a href="#raw-format" aria-label="Raw Format">Raw Format</a></li>
                <li>
                    <a href="#qcow2-format" aria-label="Qcow2 Format">Qcow2 Format</a></li></ul>
                </li>
                <li>
                    <a href="#tip-one---resize-an-image-file" aria-label="Tip One - Resize an image file">Tip One - Resize an image file</a></li>
                <li>
                    <a href="#tip-two---snapshots" aria-label="Tip Two - Snapshots">Tip Two - Snapshots</a></li>
                <li>
                    <a href="#tip-three---modify-a-qemu-image" aria-label="Tip Three - Modify a QEMU image">Tip Three - Modify a QEMU image</a></li>
                <li>
                    <a href="#tip-four---transfer-a-qemu-image-to-bare-metal" aria-label="Tip Four - Transfer a QEMU image to bare-metal">Tip Four - Transfer a QEMU image to bare-metal</a></li>
                <li>
                    <a href="#putting-it-all-together" aria-label="Putting it all together">Putting it all together</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="about-qemu-images">About QEMU images<a hidden class="anchor" aria-hidden="true" href="#about-qemu-images">#</a></h1>
<p>QEMU uses files to emulate storage devices, and the features available
depend on how those files are created.  While QEMU can emulate disks from Parallels and VirtualBox, I’m going to
focus on the formats most commonly used in automation and scripting, <strong>raw</strong> and <strong>qcow2</strong>.</p>
<p>The default format is raw and raw offers the fewest features.  It&rsquo;s just plain storage.  The other format qcow2
supports compression, snapshots, and copy-on-write in addition to storage.</p>
<h2 id="raw-format">Raw Format<a hidden class="anchor" aria-hidden="true" href="#raw-format">#</a></h2>
<p>Creating a raw disk with qemu-img is similar to using dd to create a block-based file. One can see this with
the output of <strong>qemu-img info</strong>.</p>
<p>Here I create two storage devices, one with qemu-img which defaults to the raw format and another with the
dd command.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img create my_disk.img +1m         
</span></span><span style="display:flex;"><span>Formatting <span style="color:#e6db74">&#39;my_disk.img&#39;</span>, fmt<span style="color:#f92672">=</span>raw size<span style="color:#f92672">=</span><span style="color:#ae81ff">1048576</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>/dev/zero of<span style="color:#f92672">=</span>my_block.file count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> bs<span style="color:#f92672">=</span>1m
</span></span><span style="display:flex;"><span>1+0 records in
</span></span><span style="display:flex;"><span>1+0 records out
</span></span></code></pre></div><p>Now let&rsquo;s use <strong>qemu-img info</strong> to confirm there&rsquo;s no difference between the two files.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img info my_disk.img  
</span></span><span style="display:flex;"><span>image: my_disk.img
</span></span><span style="display:flex;"><span>file format: raw
</span></span><span style="display:flex;"><span>virtual size: <span style="color:#ae81ff">1</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">1048576</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: <span style="color:#ae81ff">1</span> MiB
</span></span><span style="display:flex;"><span>Child node <span style="color:#e6db74">&#39;/file&#39;</span>:
</span></span><span style="display:flex;"><span>    filename: my_disk.img
</span></span><span style="display:flex;"><span>    protocol type: file
</span></span><span style="display:flex;"><span>    file length: <span style="color:#ae81ff">1</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">1048576</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    disk size: <span style="color:#ae81ff">1</span> MiB
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% qemu-img info my_block.file 
</span></span><span style="display:flex;"><span>image: my_block.file
</span></span><span style="display:flex;"><span>file format: raw
</span></span><span style="display:flex;"><span>virtual size: <span style="color:#ae81ff">1</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">1048576</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: <span style="color:#ae81ff">1</span> MiB
</span></span><span style="display:flex;"><span>Child node <span style="color:#e6db74">&#39;/file&#39;</span>:
</span></span><span style="display:flex;"><span>    filename: my_block.file
</span></span><span style="display:flex;"><span>    protocol type: file
</span></span><span style="display:flex;"><span>    file length: <span style="color:#ae81ff">1</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">1048576</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    disk size: <span style="color:#ae81ff">1</span> MiB
</span></span></code></pre></div><h2 id="qcow2-format">Qcow2 Format<a hidden class="anchor" aria-hidden="true" href="#qcow2-format">#</a></h2>
<p>Creating a disk in <strong>qcow2</strong> format enables zlib compression by default.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img create -f qcow2 my_disk.img 1M 
</span></span><span style="display:flex;"><span>Formatting <span style="color:#e6db74">&#39;my_disk.img&#39;</span>, fmt<span style="color:#f92672">=</span>qcow2 cluster_size<span style="color:#f92672">=</span><span style="color:#ae81ff">65536</span> extended_l2<span style="color:#f92672">=</span>off compression_type<span style="color:#f92672">=</span>zlib size<span style="color:#f92672">=</span><span style="color:#ae81ff">1048576</span> lazy_refcounts<span style="color:#f92672">=</span>off refcount_bits<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% qemu-img info my_disk.img 
</span></span><span style="display:flex;"><span>image: my_disk.img
</span></span><span style="display:flex;"><span>file format: qcow2
</span></span><span style="display:flex;"><span>virtual size: <span style="color:#ae81ff">1</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">1048576</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: <span style="color:#ae81ff">196</span> KiB
</span></span><span style="display:flex;"><span>cluster_size: <span style="color:#ae81ff">65536</span>
</span></span><span style="display:flex;"><span>Format specific information:
</span></span><span style="display:flex;"><span>    compat: 1.1
</span></span><span style="display:flex;"><span>    compression type: zlib
</span></span><span style="display:flex;"><span>    lazy refcounts: false
</span></span><span style="display:flex;"><span>    refcount bits: <span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>    corrupt: false
</span></span><span style="display:flex;"><span>    extended l2: false
</span></span><span style="display:flex;"><span>Child node <span style="color:#e6db74">&#39;/file&#39;</span>:
</span></span><span style="display:flex;"><span>    filename: my_disk.img
</span></span><span style="display:flex;"><span>    protocol type: file
</span></span><span style="display:flex;"><span>    file length: <span style="color:#ae81ff">192</span> KiB <span style="color:#f92672">(</span><span style="color:#ae81ff">197120</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    disk size: <span style="color:#ae81ff">196</span> KiB
</span></span></code></pre></div><h1 id="tip-one---resize-an-image-file">Tip One - Resize an image file<a hidden class="anchor" aria-hidden="true" href="#tip-one---resize-an-image-file">#</a></h1>
<p>It&rsquo;s possible to grow or shrink a QEMU storage device.  Think of this as expanding the physical SSD itself, not the filesystem
that sits on it.  <strong>Important,</strong> when shrinking a image with negative values,
<strong>always shrink the filesystem first</strong> using resize2fs before running qemu-img resize <strong>or risk data corruption.</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img resize my_disk.img +1m  
</span></span><span style="display:flex;"><span>Image resized.
</span></span></code></pre></div><p>When inspecting the new disk image, we see the new capacity is 2MB but the file size on disk is under 200KB.  This is because qcow2 supports
copy-on-write and compression.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img info my_disk.img
</span></span><span style="display:flex;"><span>image: my_disk.img
</span></span><span style="display:flex;"><span>file format: qcow2
</span></span><span style="display:flex;"><span>virtual size: <span style="color:#ae81ff">2</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">2097152</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: <span style="color:#ae81ff">196</span> KiB
</span></span><span style="display:flex;"><span>cluster_size: <span style="color:#ae81ff">65536</span>
</span></span><span style="display:flex;"><span>Format specific information:
</span></span><span style="display:flex;"><span>    compat: 1.1
</span></span><span style="display:flex;"><span>    compression type: zlib
</span></span><span style="display:flex;"><span>    lazy refcounts: false
</span></span><span style="display:flex;"><span>    refcount bits: <span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>    corrupt: false
</span></span><span style="display:flex;"><span>    extended l2: false
</span></span><span style="display:flex;"><span>Child node <span style="color:#e6db74">&#39;/file&#39;</span>:
</span></span><span style="display:flex;"><span>    filename: my_disk.img
</span></span><span style="display:flex;"><span>    protocol type: file
</span></span><span style="display:flex;"><span>    file length: <span style="color:#ae81ff">192</span> KiB <span style="color:#f92672">(</span><span style="color:#ae81ff">197120</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    disk size: <span style="color:#ae81ff">196</span> KiB
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% ls -lh my_disk.img 
</span></span><span style="display:flex;"><span>-rw-r--r--  <span style="color:#ae81ff">1</span> adam  staff   192K Apr  <span style="color:#ae81ff">6</span> 10:19 my_disk.img
</span></span></code></pre></div><p>If I were to resize a QEMU storage file formatted as raw, the file size on disk of 2MB matches the image capacity of 2MB as raw
doesn&rsquo;t support compression or copy-on-write.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img create raw_disk.img +2m
</span></span><span style="display:flex;"><span>Formatting <span style="color:#e6db74">&#39;raw_disk.img&#39;</span>, fmt<span style="color:#f92672">=</span>raw size<span style="color:#f92672">=</span><span style="color:#ae81ff">2097152</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% ls -lh raw_disk.img 
</span></span><span style="display:flex;"><span>-rw-r--r--  <span style="color:#ae81ff">1</span> adam  staff   2.0M Apr  <span style="color:#ae81ff">6</span> 10:22 raw_disk.img
</span></span></code></pre></div><h1 id="tip-two---snapshots">Tip Two - Snapshots<a hidden class="anchor" aria-hidden="true" href="#tip-two---snapshots">#</a></h1>
<p>Snapshots are supported with qcow2 devices.  These are handy for creating a base disk image that&rsquo;s shareable and later modified
for other purposes.  Snapshots also make a great backup point before making image changes.</p>
<p>To create a snapshot named &ldquo;my_first_snapshot&rdquo; inside an existing qcow2 image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img snapshot -c my_first_snapshot my_disk.img 
</span></span></code></pre></div><p>To list existing snapshots</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img snapshot -l my_disk.img 
</span></span><span style="display:flex;"><span>Snapshot list:
</span></span><span style="display:flex;"><span>ID      TAG               VM_SIZE                DATE        VM_CLOCK     ICOUNT
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>       my_first_snapshot      <span style="color:#ae81ff">0</span> B 2025-04-06 10:37:07  0000:00:00.000          <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>To revert or &ldquo;apply&rdquo; a snapshot</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img snapshot -a my_first_snapshot my_disk.img 
</span></span></code></pre></div><p>To delete a snapshot from a file</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img snapshot -d my_first_snapshot my_disk.img 
</span></span></code></pre></div><h1 id="tip-three---modify-a-qemu-image">Tip Three - Modify a QEMU image<a hidden class="anchor" aria-hidden="true" href="#tip-three---modify-a-qemu-image">#</a></h1>
<p>While many online guides suggest using the Network Block Device (NBD) kernel driver in Linux to mount and modify QEMU images, I
use a different process that also works on MacOS.  My preferred method is to boot a VM using QEMU and attaching the image as a data drive.</p>
<p>This example uses the <a href="https://dl-cdn.alpinelinux.org/alpine/v3.21/releases/x86_64/alpine-extended-3.21.3-x86_64.iso">extended x86_64 Alpine Linux ISO</a>
and a QEMU command that mounts the image as a data drive.  The Alpine extended ISO lets you log in as root with an empty password,
which makes quick edits easy.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#/bin/sh</span>
</span></span><span style="display:flex;"><span>qemu-system-x86_64 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -m 2G -smp cpus<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> -serial stdio <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -boot once<span style="color:#f92672">=</span>d  <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -drive file<span style="color:#f92672">=</span>./my_disk.img,format<span style="color:#f92672">=</span>qcow2,media<span style="color:#f92672">=</span>disk,cache<span style="color:#f92672">=</span>unsafe <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -drive file<span style="color:#f92672">=</span>./alpine-extended-3.21.2-x86_64.iso,format<span style="color:#f92672">=</span>raw,media<span style="color:#f92672">=</span>cdrom <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -nic user,model<span style="color:#f92672">=</span>virtio-net-pci,hostfwd<span style="color:#f92672">=</span>tcp::2222-:22
</span></span></code></pre></div><p>Once logged in, you&rsquo;ll see the QEMU file we want to modify listed as /dev/sda.  The device hasn&rsquo;t been formatted with a filesystem, but if
one were present it could be mounted within the VM, files edited within the image, and then unmounted.</p>
<h1 id="tip-four---transfer-a-qemu-image-to-bare-metal">Tip Four - Transfer a QEMU image to bare-metal<a hidden class="anchor" aria-hidden="true" href="#tip-four---transfer-a-qemu-image-to-bare-metal">#</a></h1>
<p>It&rsquo;s possible to use a QEMU image with bare-metal by converting it to <strong>raw</strong> format.  Use the following to convert the image from qcow2 to raw.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img convert -f qcow2 -O raw my_disk.img raw_disk.img
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% qemu-img info raw_disk.img 
</span></span><span style="display:flex;"><span>image: raw_disk.img
</span></span><span style="display:flex;"><span>file format: raw
</span></span><span style="display:flex;"><span>virtual size: <span style="color:#ae81ff">10</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">10485760</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: <span style="color:#ae81ff">10</span> MiB
</span></span><span style="display:flex;"><span>Child node <span style="color:#e6db74">&#39;/file&#39;</span>:
</span></span><span style="display:flex;"><span>    filename: raw_disk.img
</span></span><span style="display:flex;"><span>    protocol type: file
</span></span><span style="display:flex;"><span>    file length: <span style="color:#ae81ff">10</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">10485760</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    disk size: <span style="color:#ae81ff">10</span> MiB
</span></span></code></pre></div><p>Once we have the raw image, the <strong>dd</strong> command can be used to write the data to either a USB stick or physical SSD.  To avoid
any destructive commands let&rsquo;s pretend raw_disk2.img represents /dev/sdc, your verified USB thumb drive.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>raw_disk.img of<span style="color:#f92672">=</span>raw_disk2.img bs<span style="color:#f92672">=</span>1m 
</span></span><span style="display:flex;"><span>10+0 records in
</span></span><span style="display:flex;"><span>10+0 records out
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10485760</span> bytes transferred in 0.006266 secs <span style="color:#f92672">(</span><span style="color:#ae81ff">1673437600</span> bytes/sec<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>Because our raw file is only 10MB in size, only 10MB will be used on the thumb drive.  This is where follow up tools like LVM or
resize2fs will extend the filesystem to fill the entire thumb drive.  Tools used for expansion depends on how the filesystem was created.</p>
<h1 id="putting-it-all-together">Putting it all together<a hidden class="anchor" aria-hidden="true" href="#putting-it-all-together">#</a></h1>
<p>Enough with the documentation, let&rsquo;s put it into practice with a real use case.  Presume that after reading my <a href="../../../articles/cloudinit/intro/">cloud-init
tutorials</a> you wish to modify the <a href="https://dl-cdn.alpinelinux.org/alpine/v3.21/releases/cloud/nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2">Alpine Linux cloud-init image</a> before installation.</p>
<p>We can see the downloaded file is a qcow2 image with a capacity of 200Mb from <strong>qemu-img info</strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span> % qemu-img info nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 
</span></span><span style="display:flex;"><span>image: nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2
</span></span><span style="display:flex;"><span>file format: qcow2
</span></span><span style="display:flex;"><span>virtual size: <span style="color:#ae81ff">200</span> MiB <span style="color:#f92672">(</span><span style="color:#ae81ff">209715200</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: <span style="color:#ae81ff">181</span> MiB
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>As we want to install our java app into the installer, we need to add space to the image with <strong>qemu-img resize</strong>.  But first,
let’s create a snapshot. That way, if we make a mistake, we won’t need to re-download the cloud-init image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img snapshot -c no_modifications nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>% qemu-img resize nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 +800M
</span></span><span style="display:flex;"><span>Image resized.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> % qemu-img info nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2        
</span></span><span style="display:flex;"><span>image: nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2
</span></span><span style="display:flex;"><span>file format: qcow2
</span></span><span style="display:flex;"><span>virtual size: 0.977 GiB <span style="color:#f92672">(</span><span style="color:#ae81ff">1048576000</span> bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>disk size: <span style="color:#ae81ff">197</span> MiB
</span></span><span style="display:flex;"><span>cluster_size: <span style="color:#ae81ff">65536</span>
</span></span><span style="display:flex;"><span>Snapshot list:
</span></span><span style="display:flex;"><span>ID      TAG               VM_SIZE                DATE        VM_CLOCK     ICOUNT
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>       no_modifications      <span style="color:#ae81ff">0</span> B 2025-04-06 15:23:50  0000:00:00.000          <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>Format specific information:
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>I&rsquo;m still using the Alpine extended ISO to boot the VM. Alpine cloud images require setup for ssh key authentication to login and an
empty root password is much easier to use.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-system-x86_64 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -m 2G -smp cpus<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> -serial stdio <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -boot once<span style="color:#f92672">=</span>d  <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -drive file<span style="color:#f92672">=</span>./nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2,format<span style="color:#f92672">=</span>qcow2,media<span style="color:#f92672">=</span>disk,cache<span style="color:#f92672">=</span>unsafe <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -drive file<span style="color:#f92672">=</span>./alpine-extended-3.21.2-x86_64.iso,format<span style="color:#f92672">=</span>raw,media<span style="color:#f92672">=</span>cdrom <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -nic user,model<span style="color:#f92672">=</span>virtio-net-pci,hostfwd<span style="color:#f92672">=</span>tcp::2222-:22
</span></span></code></pre></div><p>Login as root and mount the disk device under /mnt</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>localhost:~# mount /dev/sda /mnt 
</span></span><span style="display:flex;"><span>localhost:~# ls /mnt
</span></span><span style="display:flex;"><span>bin         home        mnt         run         tmp
</span></span><span style="display:flex;"><span>boot        lib         opt         sbin        usr
</span></span><span style="display:flex;"><span>dev         lost+found  proc        srv         var
</span></span><span style="display:flex;"><span>etc         media       root        sys
</span></span></code></pre></div><p>Then make changes to the cloud image, unmount the filesystem and you&rsquo;re done.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>localhost:~# echo <span style="color:#e6db74">&#34;Adam Faris was here&#34;</span> &gt; /mnt/etc/motd 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>localhost:~# cat /mnt/etc/motd 
</span></span><span style="display:flex;"><span>Adam Faris was here
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>localhost:~# umount /mnt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>localhost:~# poweroff
</span></span></code></pre></div><p>Finally, convert our modified cloud image from qcow2 format to raw format, then use dd to write the raw image to a USB device.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>% qemu-img convert -f qcow2 -O nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2 alpine_cloudinit.raw
</span></span><span style="display:flex;"><span>% dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>alpine_cloudinit.raw bs<span style="color:#f92672">=</span>1m of<span style="color:#f92672">=</span>/dev/...
</span></span></code></pre></div><p>With the modified image written to the USB device, you can now boot a physical machine from it. Thanks for sticking with me until
the end. If you find this content useful, follow me on <a href="https://@amf3.bsky.social">BlueSky social</a> for future announcements.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

<ul class="share-buttons">
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://amf3.github.io/">Adam Faris</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
